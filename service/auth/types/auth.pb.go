// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: service/auth/types/auth.proto

package types

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GetAuthNonceRequest is request type for the GetAuthNonce RPC method.
type GetAuthNonceRequest struct {
	// account_id is the account address of user
	AccountId string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	// domain is the DApp domain for this nonce
	Domain string `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
}

func (m *GetAuthNonceRequest) Reset()         { *m = GetAuthNonceRequest{} }
func (m *GetAuthNonceRequest) String() string { return proto.CompactTextString(m) }
func (*GetAuthNonceRequest) ProtoMessage()    {}
func (*GetAuthNonceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b98739ca76eebd05, []int{0}
}
func (m *GetAuthNonceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAuthNonceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAuthNonceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAuthNonceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAuthNonceRequest.Merge(m, src)
}
func (m *GetAuthNonceRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAuthNonceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAuthNonceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAuthNonceRequest proto.InternalMessageInfo

func (m *GetAuthNonceRequest) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *GetAuthNonceRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

// GetAuthNonceResponse is response type for the GetAuthNonce RPC method.
type GetAuthNonceResponse struct {
	// current_nonce defines the current nonce value, which the current_public_key is tied to
	CurrentNonce int32 `protobuf:"varint,1,opt,name=current_nonce,json=currentNonce,proto3" json:"current_nonce,omitempty"`
	// next_nonce defines the next nonce value , for which the DApp or client can update their auth public key
	NextNonce int32 `protobuf:"varint,2,opt,name=next_nonce,json=nextNonce,proto3" json:"next_nonce,omitempty"`
	// current_public_key defines the current user EDDSA public key
	CurrentPublicKey string `protobuf:"bytes,3,opt,name=current_public_key,json=currentPublicKey,proto3" json:"current_public_key,omitempty"`
	// expiry_date is the expiry timestamp of the current public key
	ExpiryDate int64 `protobuf:"varint,6,opt,name=expiry_date,json=expiryDate,proto3" json:"expiry_date,omitempty"`
}

func (m *GetAuthNonceResponse) Reset()         { *m = GetAuthNonceResponse{} }
func (m *GetAuthNonceResponse) String() string { return proto.CompactTextString(m) }
func (*GetAuthNonceResponse) ProtoMessage()    {}
func (*GetAuthNonceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b98739ca76eebd05, []int{1}
}
func (m *GetAuthNonceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAuthNonceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAuthNonceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAuthNonceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAuthNonceResponse.Merge(m, src)
}
func (m *GetAuthNonceResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetAuthNonceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAuthNonceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAuthNonceResponse proto.InternalMessageInfo

func (m *GetAuthNonceResponse) GetCurrentNonce() int32 {
	if m != nil {
		return m.CurrentNonce
	}
	return 0
}

func (m *GetAuthNonceResponse) GetNextNonce() int32 {
	if m != nil {
		return m.NextNonce
	}
	return 0
}

func (m *GetAuthNonceResponse) GetCurrentPublicKey() string {
	if m != nil {
		return m.CurrentPublicKey
	}
	return ""
}

func (m *GetAuthNonceResponse) GetExpiryDate() int64 {
	if m != nil {
		return m.ExpiryDate
	}
	return 0
}

// UpdateUserPublicKeyRequest is request type for the UpdateUserPublicKey RPC method.
type UpdateUserPublicKeyRequest struct {
	// account_id is the account address of user
	AccountId string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	// domain is the DApp domain for which the public key is updated
	Domain string `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
	// current_nonce is the current_nonce value for which the existing public key is matching
	CurrentNonce int32 `protobuf:"varint,3,opt,name=current_nonce,json=currentNonce,proto3" json:"current_nonce,omitempty"`
	// nonce is the nonce value for which the public key is updated
	Nonce int32 `protobuf:"varint,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// user_public_key is the public key value to update in SP database
	UserPublicKey string `protobuf:"bytes,5,opt,name=user_public_key,json=userPublicKey,proto3" json:"user_public_key,omitempty"`
	// expiry_date is the expiry timestamp of the public key
	ExpiryDate int64 `protobuf:"varint,6,opt,name=expiry_date,json=expiryDate,proto3" json:"expiry_date,omitempty"`
}

func (m *UpdateUserPublicKeyRequest) Reset()         { *m = UpdateUserPublicKeyRequest{} }
func (m *UpdateUserPublicKeyRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateUserPublicKeyRequest) ProtoMessage()    {}
func (*UpdateUserPublicKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b98739ca76eebd05, []int{2}
}
func (m *UpdateUserPublicKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateUserPublicKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateUserPublicKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateUserPublicKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateUserPublicKeyRequest.Merge(m, src)
}
func (m *UpdateUserPublicKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateUserPublicKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateUserPublicKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateUserPublicKeyRequest proto.InternalMessageInfo

func (m *UpdateUserPublicKeyRequest) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *UpdateUserPublicKeyRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *UpdateUserPublicKeyRequest) GetCurrentNonce() int32 {
	if m != nil {
		return m.CurrentNonce
	}
	return 0
}

func (m *UpdateUserPublicKeyRequest) GetNonce() int32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *UpdateUserPublicKeyRequest) GetUserPublicKey() string {
	if m != nil {
		return m.UserPublicKey
	}
	return ""
}

func (m *UpdateUserPublicKeyRequest) GetExpiryDate() int64 {
	if m != nil {
		return m.ExpiryDate
	}
	return 0
}

// UpdateUserPublicKeyResponse is response type for the UpdateUserPublicKey RPC method.
type UpdateUserPublicKeyResponse struct {
	// result defines the result of if the user public key is updated
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *UpdateUserPublicKeyResponse) Reset()         { *m = UpdateUserPublicKeyResponse{} }
func (m *UpdateUserPublicKeyResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateUserPublicKeyResponse) ProtoMessage()    {}
func (*UpdateUserPublicKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b98739ca76eebd05, []int{3}
}
func (m *UpdateUserPublicKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateUserPublicKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateUserPublicKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateUserPublicKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateUserPublicKeyResponse.Merge(m, src)
}
func (m *UpdateUserPublicKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateUserPublicKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateUserPublicKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateUserPublicKeyResponse proto.InternalMessageInfo

func (m *UpdateUserPublicKeyResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

// VerifyOffChainSignatureRequest is request type for the VerifyOffChainSignature RPC method.
type VerifyOffChainSignatureRequest struct {
	// account_id is the account address of user
	AccountId string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	// domain is the DApp domain for which the public key is updated
	Domain string `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
	// off_chain_sig is the off chain signature signed by user's eddsa seed private key
	OffChainSig string `protobuf:"bytes,3,opt,name=off_chain_sig,json=offChainSig,proto3" json:"off_chain_sig,omitempty"`
	// real_msg_to_sign is the msg that the off_chain_sig is signed for
	RealMsgToSign string `protobuf:"bytes,4,opt,name=real_msg_to_sign,json=realMsgToSign,proto3" json:"real_msg_to_sign,omitempty"`
}

func (m *VerifyOffChainSignatureRequest) Reset()         { *m = VerifyOffChainSignatureRequest{} }
func (m *VerifyOffChainSignatureRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyOffChainSignatureRequest) ProtoMessage()    {}
func (*VerifyOffChainSignatureRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b98739ca76eebd05, []int{4}
}
func (m *VerifyOffChainSignatureRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyOffChainSignatureRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyOffChainSignatureRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyOffChainSignatureRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyOffChainSignatureRequest.Merge(m, src)
}
func (m *VerifyOffChainSignatureRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyOffChainSignatureRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyOffChainSignatureRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyOffChainSignatureRequest proto.InternalMessageInfo

func (m *VerifyOffChainSignatureRequest) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *VerifyOffChainSignatureRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *VerifyOffChainSignatureRequest) GetOffChainSig() string {
	if m != nil {
		return m.OffChainSig
	}
	return ""
}

func (m *VerifyOffChainSignatureRequest) GetRealMsgToSign() string {
	if m != nil {
		return m.RealMsgToSign
	}
	return ""
}

// VerifyOffChainSignatureResponse is response type for the VerifyOffChainSignature RPC method.
type VerifyOffChainSignatureResponse struct {
	// result defines the result of if the OffChainSignature is verified
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *VerifyOffChainSignatureResponse) Reset()         { *m = VerifyOffChainSignatureResponse{} }
func (m *VerifyOffChainSignatureResponse) String() string { return proto.CompactTextString(m) }
func (*VerifyOffChainSignatureResponse) ProtoMessage()    {}
func (*VerifyOffChainSignatureResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b98739ca76eebd05, []int{5}
}
func (m *VerifyOffChainSignatureResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyOffChainSignatureResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyOffChainSignatureResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyOffChainSignatureResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyOffChainSignatureResponse.Merge(m, src)
}
func (m *VerifyOffChainSignatureResponse) XXX_Size() int {
	return m.Size()
}
func (m *VerifyOffChainSignatureResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyOffChainSignatureResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyOffChainSignatureResponse proto.InternalMessageInfo

func (m *VerifyOffChainSignatureResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func init() {
	proto.RegisterType((*GetAuthNonceRequest)(nil), "service.auth.types.GetAuthNonceRequest")
	proto.RegisterType((*GetAuthNonceResponse)(nil), "service.auth.types.GetAuthNonceResponse")
	proto.RegisterType((*UpdateUserPublicKeyRequest)(nil), "service.auth.types.UpdateUserPublicKeyRequest")
	proto.RegisterType((*UpdateUserPublicKeyResponse)(nil), "service.auth.types.UpdateUserPublicKeyResponse")
	proto.RegisterType((*VerifyOffChainSignatureRequest)(nil), "service.auth.types.VerifyOffChainSignatureRequest")
	proto.RegisterType((*VerifyOffChainSignatureResponse)(nil), "service.auth.types.VerifyOffChainSignatureResponse")
}

func init() { proto.RegisterFile("service/auth/types/auth.proto", fileDescriptor_b98739ca76eebd05) }

var fileDescriptor_b98739ca76eebd05 = []byte{
	// 535 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x54, 0xcb, 0x6e, 0xd3, 0x40,
	0x14, 0x8d, 0x5b, 0x12, 0x91, 0x9b, 0x46, 0x54, 0xd3, 0xaa, 0x44, 0x41, 0x75, 0x2b, 0x23, 0xd1,
	0x2c, 0x88, 0x23, 0xb5, 0x62, 0x81, 0x58, 0xf1, 0x90, 0x10, 0xe2, 0x29, 0x97, 0xb0, 0x60, 0x63,
	0x39, 0xf6, 0xb5, 0x33, 0x22, 0x99, 0x31, 0xf3, 0xa8, 0x92, 0x3d, 0x1f, 0xc0, 0x47, 0xb0, 0xe1,
	0x4f, 0x58, 0x76, 0x07, 0x4b, 0x94, 0x7c, 0x02, 0x3f, 0x80, 0x3c, 0x76, 0x4a, 0x50, 0x9d, 0x16,
	0xd4, 0x9d, 0xe7, 0x9e, 0xe3, 0x33, 0xe7, 0xcc, 0xbd, 0x33, 0xb0, 0x2b, 0x51, 0x9c, 0xd0, 0x10,
	0x7b, 0x81, 0x56, 0xc3, 0x9e, 0x9a, 0xa6, 0x28, 0xcd, 0xa7, 0x9b, 0x0a, 0xae, 0x38, 0x21, 0x05,
	0xec, 0x9a, 0x9a, 0x81, 0x9d, 0x17, 0xb0, 0xf5, 0x14, 0xd5, 0x43, 0xad, 0x86, 0xaf, 0x38, 0x0b,
	0xd1, 0xc3, 0x8f, 0x1a, 0xa5, 0x22, 0xbb, 0x00, 0x41, 0x18, 0x72, 0xcd, 0x94, 0x4f, 0xa3, 0x96,
	0xb5, 0x6f, 0x75, 0xea, 0x5e, 0xbd, 0xa8, 0x3c, 0x8b, 0xc8, 0x0e, 0xd4, 0x22, 0x3e, 0x0e, 0x28,
	0x6b, 0xad, 0x19, 0xa8, 0x58, 0x39, 0x5f, 0x2d, 0xd8, 0xfe, 0x5b, 0x4e, 0xa6, 0x9c, 0x49, 0x24,
	0xb7, 0xa1, 0x19, 0x6a, 0x21, 0x90, 0x29, 0x9f, 0x65, 0x80, 0x91, 0xac, 0x7a, 0x1b, 0x45, 0xd1,
	0x90, 0xb3, 0x4d, 0x19, 0x4e, 0x16, 0x8c, 0x35, 0xc3, 0xa8, 0x67, 0x95, 0x1c, 0xbe, 0x0b, 0x64,
	0xa1, 0x91, 0xea, 0xc1, 0x88, 0x86, 0xfe, 0x07, 0x9c, 0xb6, 0xd6, 0x8d, 0x81, 0xcd, 0x02, 0x79,
	0x63, 0x80, 0xe7, 0x38, 0x25, 0x7b, 0xd0, 0xc0, 0x49, 0x4a, 0xc5, 0xd4, 0x8f, 0x02, 0x85, 0xad,
	0xda, 0xbe, 0xd5, 0x59, 0xf7, 0x20, 0x2f, 0x3d, 0x09, 0x14, 0x3a, 0xdf, 0x2d, 0x68, 0xf7, 0xd3,
	0x0c, 0xec, 0x4b, 0x14, 0x67, 0x3f, 0x5e, 0xed, 0x04, 0xce, 0x07, 0x5d, 0x2f, 0x09, 0xba, 0x0d,
	0xd5, 0x1c, 0xbc, 0x66, 0xc0, 0x7c, 0x41, 0xee, 0xc0, 0x0d, 0x2d, 0x51, 0x2c, 0x87, 0xab, 0x1a,
	0xed, 0xa6, 0x5e, 0x36, 0x78, 0x79, 0xb2, 0x7b, 0x70, 0xab, 0x34, 0x58, 0xd1, 0x8b, 0x1d, 0xa8,
	0x09, 0x94, 0x7a, 0xa4, 0x4c, 0xaa, 0xeb, 0x5e, 0xb1, 0x72, 0xbe, 0x58, 0x60, 0xbf, 0x43, 0x41,
	0xe3, 0xe9, 0xeb, 0x38, 0x7e, 0x3c, 0x0c, 0x28, 0x3b, 0xa6, 0x09, 0x0b, 0x94, 0x16, 0x57, 0x1c,
	0x0b, 0xe2, 0x40, 0x93, 0xc7, 0xb1, 0x1f, 0x66, 0x9a, 0xbe, 0xa4, 0x49, 0xd1, 0xb4, 0x06, 0xff,
	0xb3, 0x0f, 0x39, 0x80, 0x4d, 0x81, 0xc1, 0xc8, 0x1f, 0xcb, 0xc4, 0x57, 0x3c, 0x63, 0x31, 0x73,
	0x3c, 0x75, 0xaf, 0x99, 0xd5, 0x5f, 0xca, 0xe4, 0x2d, 0xcf, 0xfc, 0x38, 0xf7, 0x61, 0x6f, 0xa5,
	0xcb, 0x8b, 0x13, 0x1e, 0xfe, 0x5a, 0x83, 0x46, 0x36, 0x9b, 0xc7, 0xf9, 0x3d, 0x20, 0x21, 0x6c,
	0x2c, 0x4f, 0x2b, 0x39, 0x70, 0xcf, 0xdf, 0x10, 0xb7, 0xe4, 0x7a, 0xb4, 0x3b, 0x97, 0x13, 0x73,
	0x2b, 0x4e, 0x85, 0x4c, 0x60, 0xab, 0xa4, 0x1b, 0xc4, 0x2d, 0x93, 0x58, 0x3d, 0x8f, 0xed, 0xde,
	0x3f, 0xf3, 0xcf, 0x76, 0xfe, 0x64, 0xc1, 0xcd, 0x15, 0x47, 0x45, 0x0e, 0xcb, 0xe4, 0x2e, 0xee,
	0x7e, 0xfb, 0xe8, 0xbf, 0xfe, 0x59, 0xd8, 0x78, 0xd4, 0xff, 0x36, 0xb3, 0xad, 0xd3, 0x99, 0x6d,
	0xfd, 0x9c, 0xd9, 0xd6, 0xe7, 0xb9, 0x5d, 0x39, 0x9d, 0xdb, 0x95, 0x1f, 0x73, 0xbb, 0xf2, 0xfe,
	0x41, 0x42, 0xd5, 0x50, 0x0f, 0xdc, 0x90, 0x8f, 0x7b, 0x03, 0x36, 0xe8, 0x9a, 0x01, 0xe9, 0x25,
	0x02, 0x91, 0xc5, 0x14, 0x47, 0x51, 0x57, 0x2a, 0x2e, 0x82, 0x04, 0xbb, 0xa9, 0xe0, 0x27, 0x34,
	0x42, 0xb1, 0xf4, 0xb0, 0x0d, 0x6a, 0xe6, 0x51, 0x3b, 0xfa, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x39,
	0x37, 0xdb, 0xce, 0xf5, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AuthServiceClient interface {
	// GetAuthNonce get the auth nonce for which the Dapp or client can generate EDDSA key pairs.
	GetAuthNonce(ctx context.Context, in *GetAuthNonceRequest, opts ...grpc.CallOption) (*GetAuthNonceResponse, error)
	// UpdateUserPublicKey updates the user public key once the Dapp or client generates the EDDSA key pairs.
	UpdateUserPublicKey(ctx context.Context, in *UpdateUserPublicKeyRequest, opts ...grpc.CallOption) (*UpdateUserPublicKeyResponse, error)
	// VerifyOffChainSignature verifies the signature signed by user's EDDSA private key.
	VerifyOffChainSignature(ctx context.Context, in *VerifyOffChainSignatureRequest, opts ...grpc.CallOption) (*VerifyOffChainSignatureResponse, error)
}

type authServiceClient struct {
	cc grpc1.ClientConn
}

func NewAuthServiceClient(cc grpc1.ClientConn) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) GetAuthNonce(ctx context.Context, in *GetAuthNonceRequest, opts ...grpc.CallOption) (*GetAuthNonceResponse, error) {
	out := new(GetAuthNonceResponse)
	err := c.cc.Invoke(ctx, "/service.auth.types.AuthService/GetAuthNonce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpdateUserPublicKey(ctx context.Context, in *UpdateUserPublicKeyRequest, opts ...grpc.CallOption) (*UpdateUserPublicKeyResponse, error) {
	out := new(UpdateUserPublicKeyResponse)
	err := c.cc.Invoke(ctx, "/service.auth.types.AuthService/UpdateUserPublicKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) VerifyOffChainSignature(ctx context.Context, in *VerifyOffChainSignatureRequest, opts ...grpc.CallOption) (*VerifyOffChainSignatureResponse, error) {
	out := new(VerifyOffChainSignatureResponse)
	err := c.cc.Invoke(ctx, "/service.auth.types.AuthService/VerifyOffChainSignature", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
type AuthServiceServer interface {
	// GetAuthNonce get the auth nonce for which the Dapp or client can generate EDDSA key pairs.
	GetAuthNonce(context.Context, *GetAuthNonceRequest) (*GetAuthNonceResponse, error)
	// UpdateUserPublicKey updates the user public key once the Dapp or client generates the EDDSA key pairs.
	UpdateUserPublicKey(context.Context, *UpdateUserPublicKeyRequest) (*UpdateUserPublicKeyResponse, error)
	// VerifyOffChainSignature verifies the signature signed by user's EDDSA private key.
	VerifyOffChainSignature(context.Context, *VerifyOffChainSignatureRequest) (*VerifyOffChainSignatureResponse, error)
}

// UnimplementedAuthServiceServer can be embedded to have forward compatible implementations.
type UnimplementedAuthServiceServer struct {
}

func (*UnimplementedAuthServiceServer) GetAuthNonce(ctx context.Context, req *GetAuthNonceRequest) (*GetAuthNonceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuthNonce not implemented")
}
func (*UnimplementedAuthServiceServer) UpdateUserPublicKey(ctx context.Context, req *UpdateUserPublicKeyRequest) (*UpdateUserPublicKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserPublicKey not implemented")
}
func (*UnimplementedAuthServiceServer) VerifyOffChainSignature(ctx context.Context, req *VerifyOffChainSignatureRequest) (*VerifyOffChainSignatureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyOffChainSignature not implemented")
}

func RegisterAuthServiceServer(s grpc1.Server, srv AuthServiceServer) {
	s.RegisterService(&_AuthService_serviceDesc, srv)
}

func _AuthService_GetAuthNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAuthNonceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetAuthNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.auth.types.AuthService/GetAuthNonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetAuthNonce(ctx, req.(*GetAuthNonceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpdateUserPublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserPublicKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpdateUserPublicKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.auth.types.AuthService/UpdateUserPublicKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpdateUserPublicKey(ctx, req.(*UpdateUserPublicKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_VerifyOffChainSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyOffChainSignatureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).VerifyOffChainSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.auth.types.AuthService/VerifyOffChainSignature",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).VerifyOffChainSignature(ctx, req.(*VerifyOffChainSignatureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AuthService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "service.auth.types.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAuthNonce",
			Handler:    _AuthService_GetAuthNonce_Handler,
		},
		{
			MethodName: "UpdateUserPublicKey",
			Handler:    _AuthService_UpdateUserPublicKey_Handler,
		},
		{
			MethodName: "VerifyOffChainSignature",
			Handler:    _AuthService_VerifyOffChainSignature_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/auth/types/auth.proto",
}

func (m *GetAuthNonceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAuthNonceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAuthNonceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountId) > 0 {
		i -= len(m.AccountId)
		copy(dAtA[i:], m.AccountId)
		i = encodeVarintAuth(dAtA, i, uint64(len(m.AccountId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAuthNonceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAuthNonceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAuthNonceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiryDate != 0 {
		i = encodeVarintAuth(dAtA, i, uint64(m.ExpiryDate))
		i--
		dAtA[i] = 0x30
	}
	if len(m.CurrentPublicKey) > 0 {
		i -= len(m.CurrentPublicKey)
		copy(dAtA[i:], m.CurrentPublicKey)
		i = encodeVarintAuth(dAtA, i, uint64(len(m.CurrentPublicKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NextNonce != 0 {
		i = encodeVarintAuth(dAtA, i, uint64(m.NextNonce))
		i--
		dAtA[i] = 0x10
	}
	if m.CurrentNonce != 0 {
		i = encodeVarintAuth(dAtA, i, uint64(m.CurrentNonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateUserPublicKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserPublicKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateUserPublicKeyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiryDate != 0 {
		i = encodeVarintAuth(dAtA, i, uint64(m.ExpiryDate))
		i--
		dAtA[i] = 0x30
	}
	if len(m.UserPublicKey) > 0 {
		i -= len(m.UserPublicKey)
		copy(dAtA[i:], m.UserPublicKey)
		i = encodeVarintAuth(dAtA, i, uint64(len(m.UserPublicKey)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Nonce != 0 {
		i = encodeVarintAuth(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x20
	}
	if m.CurrentNonce != 0 {
		i = encodeVarintAuth(dAtA, i, uint64(m.CurrentNonce))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountId) > 0 {
		i -= len(m.AccountId)
		copy(dAtA[i:], m.AccountId)
		i = encodeVarintAuth(dAtA, i, uint64(len(m.AccountId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateUserPublicKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserPublicKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateUserPublicKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VerifyOffChainSignatureRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyOffChainSignatureRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyOffChainSignatureRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RealMsgToSign) > 0 {
		i -= len(m.RealMsgToSign)
		copy(dAtA[i:], m.RealMsgToSign)
		i = encodeVarintAuth(dAtA, i, uint64(len(m.RealMsgToSign)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OffChainSig) > 0 {
		i -= len(m.OffChainSig)
		copy(dAtA[i:], m.OffChainSig)
		i = encodeVarintAuth(dAtA, i, uint64(len(m.OffChainSig)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountId) > 0 {
		i -= len(m.AccountId)
		copy(dAtA[i:], m.AccountId)
		i = encodeVarintAuth(dAtA, i, uint64(len(m.AccountId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifyOffChainSignatureResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyOffChainSignatureResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyOffChainSignatureResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintAuth(dAtA []byte, offset int, v uint64) int {
	offset -= sovAuth(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GetAuthNonceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *GetAuthNonceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CurrentNonce != 0 {
		n += 1 + sovAuth(uint64(m.CurrentNonce))
	}
	if m.NextNonce != 0 {
		n += 1 + sovAuth(uint64(m.NextNonce))
	}
	l = len(m.CurrentPublicKey)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.ExpiryDate != 0 {
		n += 1 + sovAuth(uint64(m.ExpiryDate))
	}
	return n
}

func (m *UpdateUserPublicKeyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.CurrentNonce != 0 {
		n += 1 + sovAuth(uint64(m.CurrentNonce))
	}
	if m.Nonce != 0 {
		n += 1 + sovAuth(uint64(m.Nonce))
	}
	l = len(m.UserPublicKey)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.ExpiryDate != 0 {
		n += 1 + sovAuth(uint64(m.ExpiryDate))
	}
	return n
}

func (m *UpdateUserPublicKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func (m *VerifyOffChainSignatureRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.OffChainSig)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.RealMsgToSign)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *VerifyOffChainSignatureResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func sovAuth(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAuth(x uint64) (n int) {
	return sovAuth(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetAuthNonceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAuthNonceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAuthNonceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuth
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuth
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAuthNonceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAuthNonceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAuthNonceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentNonce", wireType)
			}
			m.CurrentNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentNonce |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextNonce", wireType)
			}
			m.NextNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextNonce |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentPublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuth
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentPublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryDate", wireType)
			}
			m.ExpiryDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryDate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserPublicKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserPublicKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserPublicKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuth
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuth
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentNonce", wireType)
			}
			m.CurrentNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentNonce |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuth
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserPublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryDate", wireType)
			}
			m.ExpiryDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryDate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserPublicKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserPublicKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserPublicKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyOffChainSignatureRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyOffChainSignatureRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyOffChainSignatureRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuth
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuth
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffChainSig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuth
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OffChainSig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealMsgToSign", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuth
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RealMsgToSign = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyOffChainSignatureResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyOffChainSignatureResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyOffChainSignatureResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuth(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAuth
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAuth
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAuth
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAuth        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuth          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAuth = fmt.Errorf("proto: unexpected end of group")
)
