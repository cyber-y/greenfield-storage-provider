// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: service/types/storage_provider.proto

package types

import (
	fmt "fmt"
	types "github.com/bnb-chain/greenfield/x/storage/types"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type JobType int32

const (
	JobType_JOB_TYPE_UNSPECIFIED   JobType = 0
	JobType_JOB_TYPE_UPLOAD_OBJECT JobType = 1
	JobType_JOB_TYPE_DELETE_OBJECT JobType = 2
)

var JobType_name = map[int32]string{
	0: "JOB_TYPE_UNSPECIFIED",
	1: "JOB_TYPE_UPLOAD_OBJECT",
	2: "JOB_TYPE_DELETE_OBJECT",
}

var JobType_value = map[string]int32{
	"JOB_TYPE_UNSPECIFIED":   0,
	"JOB_TYPE_UPLOAD_OBJECT": 1,
	"JOB_TYPE_DELETE_OBJECT": 2,
}

func (x JobType) String() string {
	return proto.EnumName(JobType_name, int32(x))
}

func (JobType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4c4f79ce772b8b4a, []int{0}
}

type JobState int32

const (
	JobState_JOB_STATE_INIT_UNSPECIFIED       JobState = 0
	JobState_JOB_STATE_UPLOAD_OBJECT_DOING    JobState = 1
	JobState_JOB_STATE_UPLOAD_OBJECT_DONE     JobState = 2
	JobState_JOB_STATE_UPLOAD_OBJECT_ERROR    JobState = 3
	JobState_JOB_STATE_ALLOC_SECONDARY_DOING  JobState = 4
	JobState_JOB_STATE_ALLOC_SECONDARY_DONE   JobState = 5
	JobState_JOB_STATE_ALLOC_SECONDARY_ERROR  JobState = 6
	JobState_JOB_STATE_REPLICATE_OBJECT_DOING JobState = 7
	JobState_JOB_STATE_REPLICATE_OBJECT_DONE  JobState = 8
	JobState_JOB_STATE_REPLICATE_OBJECT_ERROR JobState = 9
	JobState_JOB_STATE_SIGN_OBJECT_DOING      JobState = 10
	JobState_JOB_STATE_SIGN_OBJECT_DONE       JobState = 11
	JobState_JOB_STATE_SIGN_OBJECT_ERROR      JobState = 12
	JobState_JOB_STATE_SEAL_OBJECT_DOING      JobState = 13
	JobState_JOB_STATE_SEAL_OBJECT_DONE       JobState = 14
	JobState_JOB_STATE_SEAL_OBJECT_ERROR      JobState = 15
)

var JobState_name = map[int32]string{
	0:  "JOB_STATE_INIT_UNSPECIFIED",
	1:  "JOB_STATE_UPLOAD_OBJECT_DOING",
	2:  "JOB_STATE_UPLOAD_OBJECT_DONE",
	3:  "JOB_STATE_UPLOAD_OBJECT_ERROR",
	4:  "JOB_STATE_ALLOC_SECONDARY_DOING",
	5:  "JOB_STATE_ALLOC_SECONDARY_DONE",
	6:  "JOB_STATE_ALLOC_SECONDARY_ERROR",
	7:  "JOB_STATE_REPLICATE_OBJECT_DOING",
	8:  "JOB_STATE_REPLICATE_OBJECT_DONE",
	9:  "JOB_STATE_REPLICATE_OBJECT_ERROR",
	10: "JOB_STATE_SIGN_OBJECT_DOING",
	11: "JOB_STATE_SIGN_OBJECT_DONE",
	12: "JOB_STATE_SIGN_OBJECT_ERROR",
	13: "JOB_STATE_SEAL_OBJECT_DOING",
	14: "JOB_STATE_SEAL_OBJECT_DONE",
	15: "JOB_STATE_SEAL_OBJECT_ERROR",
}

var JobState_value = map[string]int32{
	"JOB_STATE_INIT_UNSPECIFIED":       0,
	"JOB_STATE_UPLOAD_OBJECT_DOING":    1,
	"JOB_STATE_UPLOAD_OBJECT_DONE":     2,
	"JOB_STATE_UPLOAD_OBJECT_ERROR":    3,
	"JOB_STATE_ALLOC_SECONDARY_DOING":  4,
	"JOB_STATE_ALLOC_SECONDARY_DONE":   5,
	"JOB_STATE_ALLOC_SECONDARY_ERROR":  6,
	"JOB_STATE_REPLICATE_OBJECT_DOING": 7,
	"JOB_STATE_REPLICATE_OBJECT_DONE":  8,
	"JOB_STATE_REPLICATE_OBJECT_ERROR": 9,
	"JOB_STATE_SIGN_OBJECT_DOING":      10,
	"JOB_STATE_SIGN_OBJECT_DONE":       11,
	"JOB_STATE_SIGN_OBJECT_ERROR":      12,
	"JOB_STATE_SEAL_OBJECT_DOING":      13,
	"JOB_STATE_SEAL_OBJECT_DONE":       14,
	"JOB_STATE_SEAL_OBJECT_ERROR":      15,
}

func (x JobState) String() string {
	return proto.EnumName(JobState_name, int32(x))
}

func (JobState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4c4f79ce772b8b4a, []int{1}
}

// JobContext defines the job information.
type JobContext struct {
	// job_id defines the unique id of a job.
	JobId uint64 `protobuf:"varint,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// job_type defines the type of a job.
	JobType JobType `protobuf:"varint,2,opt,name=job_type,json=jobType,proto3,enum=service.types.JobType" json:"job_type,omitempty"`
	// job_state defines the state of a job.
	JobState JobState `protobuf:"varint,3,opt,name=job_state,json=jobState,proto3,enum=service.types.JobState" json:"job_state,omitempty"`
	// job_error_code defines the error code when a job abnormal termination.
	JobErrorCode uint32 `protobuf:"varint,4,opt,name=job_error_code,json=jobErrorCode,proto3" json:"job_error_code,omitempty"`
	// create_time defines the job create time, used to jobs garbage collection.
	CreateTime int64 `protobuf:"varint,5,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// modify_time defines the job last modified time, used to judge timeout
	ModifyTime int64 `protobuf:"varint,6,opt,name=modify_time,json=modifyTime,proto3" json:"modify_time,omitempty"`
}

func (m *JobContext) Reset()         { *m = JobContext{} }
func (m *JobContext) String() string { return proto.CompactTextString(m) }
func (*JobContext) ProtoMessage()    {}
func (*JobContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c4f79ce772b8b4a, []int{0}
}
func (m *JobContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobContext.Merge(m, src)
}
func (m *JobContext) XXX_Size() int {
	return m.Size()
}
func (m *JobContext) XXX_DiscardUnknown() {
	xxx_messageInfo_JobContext.DiscardUnknown(m)
}

var xxx_messageInfo_JobContext proto.InternalMessageInfo

func (m *JobContext) GetJobId() uint64 {
	if m != nil {
		return m.JobId
	}
	return 0
}

func (m *JobContext) GetJobType() JobType {
	if m != nil {
		return m.JobType
	}
	return JobType_JOB_TYPE_UNSPECIFIED
}

func (m *JobContext) GetJobState() JobState {
	if m != nil {
		return m.JobState
	}
	return JobState_JOB_STATE_INIT_UNSPECIFIED
}

func (m *JobContext) GetJobErrorCode() uint32 {
	if m != nil {
		return m.JobErrorCode
	}
	return 0
}

func (m *JobContext) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *JobContext) GetModifyTime() int64 {
	if m != nil {
		return m.ModifyTime
	}
	return 0
}

// PieceInfo defines the information of the piece.
type PieceInfo struct {
	// object_info defines the information of the object.
	ObjectInfo *types.ObjectInfo `protobuf:"bytes,1,opt,name=object_info,json=objectInfo,proto3" json:"object_info,omitempty"`
	// check_sum defines the hash of the segments.
	Checksum [][]byte `protobuf:"bytes,2,rep,name=checksum,proto3" json:"checksum,omitempty"`
	// integrity_hash defines the hash of check_sum.
	IntegrityHash []byte `protobuf:"bytes,3,opt,name=integrity_hash,json=integrityHash,proto3" json:"integrity_hash,omitempty"`
	// signature defines the storage provider sign to the integrity hash.
	Signature []byte `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
	// completed_num defines the number of replicated piece.
	CompletedNum uint32 `protobuf:"varint,5,opt,name=completed_num,json=completedNum,proto3" json:"completed_num,omitempty"`
}

func (m *PieceInfo) Reset()         { *m = PieceInfo{} }
func (m *PieceInfo) String() string { return proto.CompactTextString(m) }
func (*PieceInfo) ProtoMessage()    {}
func (*PieceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c4f79ce772b8b4a, []int{1}
}
func (m *PieceInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PieceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PieceInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PieceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PieceInfo.Merge(m, src)
}
func (m *PieceInfo) XXX_Size() int {
	return m.Size()
}
func (m *PieceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PieceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PieceInfo proto.InternalMessageInfo

func (m *PieceInfo) GetObjectInfo() *types.ObjectInfo {
	if m != nil {
		return m.ObjectInfo
	}
	return nil
}

func (m *PieceInfo) GetChecksum() [][]byte {
	if m != nil {
		return m.Checksum
	}
	return nil
}

func (m *PieceInfo) GetIntegrityHash() []byte {
	if m != nil {
		return m.IntegrityHash
	}
	return nil
}

func (m *PieceInfo) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *PieceInfo) GetCompletedNum() uint32 {
	if m != nil {
		return m.CompletedNum
	}
	return 0
}

// ReplicatePieceInfo defines the information of the pieces that
// need to replicate to other storage providers.
type ReplicatePieceInfo struct {
	// piece_infos defines all the replicate segments info.
	PieceInfos []*PieceInfo `protobuf:"bytes,1,rep,name=piece_infos,json=pieceInfos,proto3" json:"piece_infos,omitempty"`
}

func (m *ReplicatePieceInfo) Reset()         { *m = ReplicatePieceInfo{} }
func (m *ReplicatePieceInfo) String() string { return proto.CompactTextString(m) }
func (*ReplicatePieceInfo) ProtoMessage()    {}
func (*ReplicatePieceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c4f79ce772b8b4a, []int{2}
}
func (m *ReplicatePieceInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicatePieceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicatePieceInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplicatePieceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicatePieceInfo.Merge(m, src)
}
func (m *ReplicatePieceInfo) XXX_Size() int {
	return m.Size()
}
func (m *ReplicatePieceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicatePieceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicatePieceInfo proto.InternalMessageInfo

func (m *ReplicatePieceInfo) GetPieceInfos() []*PieceInfo {
	if m != nil {
		return m.PieceInfos
	}
	return nil
}

func init() {
	proto.RegisterEnum("service.types.JobType", JobType_name, JobType_value)
	proto.RegisterEnum("service.types.JobState", JobState_name, JobState_value)
	proto.RegisterType((*JobContext)(nil), "service.types.JobContext")
	proto.RegisterType((*PieceInfo)(nil), "service.types.PieceInfo")
	proto.RegisterType((*ReplicatePieceInfo)(nil), "service.types.ReplicatePieceInfo")
}

func init() {
	proto.RegisterFile("service/types/storage_provider.proto", fileDescriptor_4c4f79ce772b8b4a)
}

var fileDescriptor_4c4f79ce772b8b4a = []byte{
	// 708 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x94, 0xdd, 0x6e, 0xe2, 0x46,
	0x14, 0xc7, 0x31, 0x10, 0x02, 0xc3, 0x47, 0xad, 0x51, 0x9b, 0x5a, 0x34, 0x75, 0x5c, 0x92, 0x4a,
	0x28, 0x52, 0x8c, 0x9a, 0xf6, 0xa6, 0x37, 0xad, 0x08, 0x4c, 0x53, 0x23, 0x64, 0xa3, 0xc1, 0x95,
	0x9a, 0xdd, 0x0b, 0xcb, 0x1f, 0x03, 0x98, 0x8d, 0x3d, 0x96, 0x3d, 0x44, 0xcb, 0x5b, 0xec, 0xcb,
	0xec, 0x3b, 0xec, 0x65, 0xb4, 0x57, 0x7b, 0xb9, 0x4a, 0x5e, 0x61, 0x1f, 0x60, 0x65, 0x1b, 0xb0,
	0xcc, 0x6e, 0xb2, 0x77, 0xc7, 0xe7, 0xfc, 0xfe, 0xe7, 0xaf, 0x73, 0xc6, 0x33, 0xe0, 0x2c, 0x22,
	0xe1, 0x9d, 0x6b, 0x93, 0x1e, 0x5b, 0x07, 0x24, 0xea, 0x45, 0x8c, 0x86, 0xe6, 0x9c, 0x18, 0x41,
	0x48, 0xef, 0x5c, 0x87, 0x84, 0x72, 0x10, 0x52, 0x46, 0x61, 0x73, 0x43, 0xc9, 0x09, 0xd5, 0x16,
	0xe7, 0x21, 0x21, 0xfe, 0xcc, 0x25, 0xb7, 0xce, 0x56, 0x91, 0xea, 0x53, 0xbc, 0xf3, 0x89, 0x03,
	0x60, 0x44, 0xad, 0x01, 0xf5, 0x19, 0x79, 0xcd, 0xe0, 0x0f, 0xa0, 0xb2, 0xa4, 0x96, 0xe1, 0x3a,
	0x02, 0x27, 0x71, 0xdd, 0x32, 0x3e, 0x58, 0x52, 0x4b, 0x71, 0xe0, 0x6f, 0xa0, 0x1a, 0xa7, 0x63,
	0xa1, 0x50, 0x94, 0xb8, 0x6e, 0xeb, 0xf2, 0x48, 0xce, 0xf9, 0xc8, 0x23, 0x6a, 0xe9, 0xeb, 0x80,
	0xe0, 0xc3, 0x65, 0x1a, 0xc0, 0x3f, 0x40, 0x2d, 0x96, 0x44, 0xcc, 0x64, 0x44, 0x28, 0x25, 0x9a,
	0x1f, 0xbf, 0xd4, 0x4c, 0xe3, 0x32, 0x8e, 0x9b, 0x27, 0x11, 0x3c, 0x03, 0xad, 0x58, 0x45, 0xc2,
	0x90, 0x86, 0x86, 0x4d, 0x1d, 0x22, 0x94, 0x25, 0xae, 0xdb, 0xc4, 0x8d, 0x25, 0xb5, 0x50, 0x9c,
	0x1c, 0x50, 0x87, 0xc0, 0x13, 0x50, 0xb7, 0x43, 0x62, 0x32, 0x62, 0x30, 0xd7, 0x23, 0xc2, 0x81,
	0xc4, 0x75, 0x4b, 0x18, 0xa4, 0x29, 0xdd, 0xf5, 0x12, 0xc0, 0xa3, 0x8e, 0x3b, 0x5b, 0xa7, 0x40,
	0x25, 0x05, 0xd2, 0x54, 0x0c, 0x74, 0xde, 0x73, 0xa0, 0x36, 0x71, 0x89, 0x4d, 0x14, 0x7f, 0x46,
	0xe1, 0xdf, 0xa0, 0x4e, 0xad, 0x25, 0xb1, 0x99, 0xe1, 0xfa, 0x33, 0x9a, 0x8c, 0x5e, 0xbf, 0x14,
	0xe5, 0x6c, 0x75, 0xf2, 0x66, 0x75, 0xb2, 0x96, 0x60, 0xb1, 0x08, 0x03, 0xba, 0x8b, 0x61, 0x1b,
	0x54, 0xed, 0x05, 0xb1, 0x5f, 0x45, 0x2b, 0x4f, 0x28, 0x4a, 0xa5, 0x6e, 0x03, 0xef, 0xbe, 0xe1,
	0xaf, 0xa0, 0xe5, 0xfa, 0x8c, 0xcc, 0x43, 0x97, 0xad, 0x8d, 0x85, 0x19, 0x2d, 0x92, 0x6d, 0x34,
	0x70, 0x73, 0x97, 0xfd, 0xd7, 0x8c, 0x16, 0xf0, 0x18, 0xd4, 0x22, 0x77, 0xee, 0x9b, 0x6c, 0x15,
	0xa6, 0x43, 0x37, 0x70, 0x96, 0x80, 0xa7, 0xa0, 0x69, 0x53, 0x2f, 0xb8, 0x25, 0x8c, 0x38, 0x86,
	0xbf, 0xf2, 0x92, 0x99, 0x9b, 0xb8, 0xb1, 0x4b, 0xaa, 0x2b, 0xaf, 0xa3, 0x01, 0x88, 0x49, 0x70,
	0xeb, 0xda, 0x26, 0x23, 0xd9, 0x70, 0x7f, 0x82, 0x7a, 0x10, 0x7f, 0x24, 0xb3, 0x45, 0x02, 0x27,
	0x95, 0xba, 0xf5, 0x4b, 0x61, 0xef, 0x28, 0x76, 0x38, 0x06, 0xc1, 0x36, 0x8c, 0xce, 0x5f, 0x82,
	0xc3, 0xcd, 0xb9, 0x42, 0x01, 0x7c, 0x3f, 0xd2, 0xae, 0x0c, 0xfd, 0x66, 0x82, 0x8c, 0xff, 0xd4,
	0xe9, 0x04, 0x0d, 0x94, 0x7f, 0x14, 0x34, 0xe4, 0x0b, 0xb0, 0x0d, 0x8e, 0xb2, 0xca, 0x64, 0xac,
	0xf5, 0x87, 0x86, 0x76, 0x35, 0x42, 0x03, 0x9d, 0xe7, 0x72, 0xb5, 0x21, 0x1a, 0x23, 0x1d, 0x6d,
	0x6b, 0xc5, 0xf3, 0xb7, 0x65, 0x50, 0xdd, 0xfe, 0x01, 0x50, 0x04, 0xed, 0x18, 0x9c, 0xea, 0x7d,
	0x1d, 0x19, 0x8a, 0xaa, 0xe8, 0x7b, 0x26, 0xbf, 0x80, 0x9f, 0xb3, 0x7a, 0xce, 0xc5, 0x18, 0x6a,
	0x8a, 0x7a, 0xcd, 0x73, 0x50, 0x02, 0xc7, 0x4f, 0x23, 0x2a, 0xe2, 0x8b, 0xcf, 0x35, 0x41, 0x18,
	0x6b, 0x98, 0x2f, 0xc1, 0x53, 0x70, 0x92, 0x21, 0xfd, 0xf1, 0x58, 0x1b, 0x18, 0x53, 0x34, 0xd0,
	0xd4, 0x61, 0x1f, 0xdf, 0x6c, 0x9c, 0xca, 0xb0, 0x03, 0xc4, 0xe7, 0x20, 0x15, 0xf1, 0x07, 0xcf,
	0x37, 0x4a, 0xdd, 0x2a, 0xf0, 0x0c, 0x48, 0x19, 0x84, 0xd1, 0x64, 0xac, 0x0c, 0xfa, 0xbb, 0x15,
	0x6d, 0xec, 0x0e, 0xf3, 0xad, 0xbe, 0x42, 0xa9, 0x88, 0xaf, 0x7e, 0xa3, 0x55, 0x6a, 0x58, 0x83,
	0x27, 0xe0, 0xa7, 0x8c, 0x9a, 0x2a, 0xd7, 0x6a, 0xde, 0x0b, 0xe4, 0xcf, 0x21, 0x0f, 0xa8, 0x88,
	0xaf, 0x3f, 0xdd, 0x20, 0x75, 0x68, 0xec, 0x01, 0xa8, 0x3f, 0xce, 0x3b, 0x34, 0xf7, 0x1c, 0x72,
	0x80, 0x8a, 0xf8, 0xd6, 0xd3, 0x0d, 0x52, 0x87, 0xef, 0xae, 0xfe, 0x7f, 0xf7, 0x20, 0x72, 0xf7,
	0x0f, 0x22, 0xf7, 0xf1, 0x41, 0xe4, 0xde, 0x3c, 0x8a, 0x85, 0xfb, 0x47, 0xb1, 0xf0, 0xe1, 0x51,
	0x2c, 0xbc, 0xf8, 0x6b, 0xee, 0xb2, 0xc5, 0xca, 0x92, 0x6d, 0xea, 0xf5, 0x2c, 0xdf, 0xba, 0xb0,
	0x17, 0xa6, 0xeb, 0xf7, 0xb2, 0x5b, 0x7c, 0xb1, 0xb9, 0xc5, 0x17, 0xdb, 0x27, 0xb3, 0x97, 0x7b,
	0x51, 0xad, 0x4a, 0xf2, 0x24, 0xfe, 0xfe, 0x39, 0x00, 0x00, 0xff, 0xff, 0x2a, 0x96, 0xa7, 0x63,
	0x69, 0x05, 0x00, 0x00,
}

func (m *JobContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ModifyTime != 0 {
		i = encodeVarintStorageProvider(dAtA, i, uint64(m.ModifyTime))
		i--
		dAtA[i] = 0x30
	}
	if m.CreateTime != 0 {
		i = encodeVarintStorageProvider(dAtA, i, uint64(m.CreateTime))
		i--
		dAtA[i] = 0x28
	}
	if m.JobErrorCode != 0 {
		i = encodeVarintStorageProvider(dAtA, i, uint64(m.JobErrorCode))
		i--
		dAtA[i] = 0x20
	}
	if m.JobState != 0 {
		i = encodeVarintStorageProvider(dAtA, i, uint64(m.JobState))
		i--
		dAtA[i] = 0x18
	}
	if m.JobType != 0 {
		i = encodeVarintStorageProvider(dAtA, i, uint64(m.JobType))
		i--
		dAtA[i] = 0x10
	}
	if m.JobId != 0 {
		i = encodeVarintStorageProvider(dAtA, i, uint64(m.JobId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PieceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PieceInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PieceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CompletedNum != 0 {
		i = encodeVarintStorageProvider(dAtA, i, uint64(m.CompletedNum))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintStorageProvider(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IntegrityHash) > 0 {
		i -= len(m.IntegrityHash)
		copy(dAtA[i:], m.IntegrityHash)
		i = encodeVarintStorageProvider(dAtA, i, uint64(len(m.IntegrityHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Checksum) > 0 {
		for iNdEx := len(m.Checksum) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Checksum[iNdEx])
			copy(dAtA[i:], m.Checksum[iNdEx])
			i = encodeVarintStorageProvider(dAtA, i, uint64(len(m.Checksum[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ObjectInfo != nil {
		{
			size, err := m.ObjectInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStorageProvider(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplicatePieceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicatePieceInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicatePieceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PieceInfos) > 0 {
		for iNdEx := len(m.PieceInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PieceInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStorageProvider(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintStorageProvider(dAtA []byte, offset int, v uint64) int {
	offset -= sovStorageProvider(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *JobContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobId != 0 {
		n += 1 + sovStorageProvider(uint64(m.JobId))
	}
	if m.JobType != 0 {
		n += 1 + sovStorageProvider(uint64(m.JobType))
	}
	if m.JobState != 0 {
		n += 1 + sovStorageProvider(uint64(m.JobState))
	}
	if m.JobErrorCode != 0 {
		n += 1 + sovStorageProvider(uint64(m.JobErrorCode))
	}
	if m.CreateTime != 0 {
		n += 1 + sovStorageProvider(uint64(m.CreateTime))
	}
	if m.ModifyTime != 0 {
		n += 1 + sovStorageProvider(uint64(m.ModifyTime))
	}
	return n
}

func (m *PieceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectInfo != nil {
		l = m.ObjectInfo.Size()
		n += 1 + l + sovStorageProvider(uint64(l))
	}
	if len(m.Checksum) > 0 {
		for _, b := range m.Checksum {
			l = len(b)
			n += 1 + l + sovStorageProvider(uint64(l))
		}
	}
	l = len(m.IntegrityHash)
	if l > 0 {
		n += 1 + l + sovStorageProvider(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovStorageProvider(uint64(l))
	}
	if m.CompletedNum != 0 {
		n += 1 + sovStorageProvider(uint64(m.CompletedNum))
	}
	return n
}

func (m *ReplicatePieceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PieceInfos) > 0 {
		for _, e := range m.PieceInfos {
			l = e.Size()
			n += 1 + l + sovStorageProvider(uint64(l))
		}
	}
	return n
}

func sovStorageProvider(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStorageProvider(x uint64) (n int) {
	return sovStorageProvider(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *JobContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProvider
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			m.JobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobType", wireType)
			}
			m.JobType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobType |= JobType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobState", wireType)
			}
			m.JobState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobState |= JobState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobErrorCode", wireType)
			}
			m.JobErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobErrorCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifyTime", wireType)
			}
			m.ModifyTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModifyTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProvider(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStorageProvider
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PieceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProvider
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PieceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PieceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorageProvider
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStorageProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectInfo == nil {
				m.ObjectInfo = &types.ObjectInfo{}
			}
			if err := m.ObjectInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorageProvider
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStorageProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checksum = append(m.Checksum, make([]byte, postIndex-iNdEx))
			copy(m.Checksum[len(m.Checksum)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntegrityHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorageProvider
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStorageProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntegrityHash = append(m.IntegrityHash[:0], dAtA[iNdEx:postIndex]...)
			if m.IntegrityHash == nil {
				m.IntegrityHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorageProvider
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStorageProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedNum", wireType)
			}
			m.CompletedNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletedNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProvider(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStorageProvider
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicatePieceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProvider
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicatePieceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicatePieceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PieceInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProvider
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorageProvider
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStorageProvider
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PieceInfos = append(m.PieceInfos, &PieceInfo{})
			if err := m.PieceInfos[len(m.PieceInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProvider(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStorageProvider
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStorageProvider(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStorageProvider
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStorageProvider
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStorageProvider
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStorageProvider
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStorageProvider
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStorageProvider
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStorageProvider        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStorageProvider          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStorageProvider = fmt.Errorf("proto: unexpected end of group")
)
