// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: modular/metadata/types/metadata.proto

package types

import (
	context "context"
	fmt "fmt"
	gfsperrors "github.com/bnb-chain/greenfield-storage-provider/base/types/gfsperrors"
	types2 "github.com/bnb-chain/greenfield-storage-provider/service/types"
	types1 "github.com/bnb-chain/greenfield/x/payment/types"
	types "github.com/bnb-chain/greenfield/x/storage/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Bucket is the structure for user bucket
type Bucket struct {
	// bucket_info defines the information of the bucket.
	BucketInfo *types.BucketInfo `protobuf:"bytes,1,opt,name=bucket_info,json=bucketInfo,proto3" json:"bucket_info,omitempty"`
	// removed defines the bucket is deleted or not
	Removed bool `protobuf:"varint,2,opt,name=removed,proto3" json:"removed,omitempty"`
	// delete_at defines the block number when the bucket deleted.
	DeleteAt int64 `protobuf:"varint,3,opt,name=delete_at,json=deleteAt,proto3" json:"delete_at,omitempty"`
	// delete_reason defines the deleted reason of bucket
	DeleteReason string `protobuf:"bytes,4,opt,name=delete_reason,json=deleteReason,proto3" json:"delete_reason,omitempty"`
	// operator defines the operator address of bucket
	Operator string `protobuf:"bytes,5,opt,name=operator,proto3" json:"operator,omitempty"`
	// create_tx_hash defines the creation transaction hash of object
	CreateTxHash string `protobuf:"bytes,6,opt,name=create_tx_hash,json=createTxHash,proto3" json:"create_tx_hash,omitempty"`
	// update_tx_hash defines the update transaction hash of object
	UpdateTxHash string `protobuf:"bytes,7,opt,name=update_tx_hash,json=updateTxHash,proto3" json:"update_tx_hash,omitempty"`
	// update_at defines the block number when the object updated
	UpdateAt int64 `protobuf:"varint,8,opt,name=update_at,json=updateAt,proto3" json:"update_at,omitempty"`
	// update_time defines the block number when the object updated
	UpdateTime int64 `protobuf:"varint,9,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
}

func (m *Bucket) Reset()         { *m = Bucket{} }
func (m *Bucket) String() string { return proto.CompactTextString(m) }
func (*Bucket) ProtoMessage()    {}
func (*Bucket) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{0}
}
func (m *Bucket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bucket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Bucket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bucket.Merge(m, src)
}
func (m *Bucket) XXX_Size() int {
	return m.Size()
}
func (m *Bucket) XXX_DiscardUnknown() {
	xxx_messageInfo_Bucket.DiscardUnknown(m)
}

var xxx_messageInfo_Bucket proto.InternalMessageInfo

func (m *Bucket) GetBucketInfo() *types.BucketInfo {
	if m != nil {
		return m.BucketInfo
	}
	return nil
}

func (m *Bucket) GetRemoved() bool {
	if m != nil {
		return m.Removed
	}
	return false
}

func (m *Bucket) GetDeleteAt() int64 {
	if m != nil {
		return m.DeleteAt
	}
	return 0
}

func (m *Bucket) GetDeleteReason() string {
	if m != nil {
		return m.DeleteReason
	}
	return ""
}

func (m *Bucket) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *Bucket) GetCreateTxHash() string {
	if m != nil {
		return m.CreateTxHash
	}
	return ""
}

func (m *Bucket) GetUpdateTxHash() string {
	if m != nil {
		return m.UpdateTxHash
	}
	return ""
}

func (m *Bucket) GetUpdateAt() int64 {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

func (m *Bucket) GetUpdateTime() int64 {
	if m != nil {
		return m.UpdateTime
	}
	return 0
}

// Object is the structure for user object
type Object struct {
	// object_info defines the information of the object.
	ObjectInfo *types.ObjectInfo `protobuf:"bytes,1,opt,name=object_info,json=objectInfo,proto3" json:"object_info,omitempty"`
	// locked_balance defines locked balance of object
	LockedBalance string `protobuf:"bytes,2,opt,name=locked_balance,json=lockedBalance,proto3" json:"locked_balance,omitempty"`
	// removed defines the object is deleted or not
	Removed bool `protobuf:"varint,3,opt,name=removed,proto3" json:"removed,omitempty"`
	// update_at defines the block number when the object updated
	UpdateAt int64 `protobuf:"varint,4,opt,name=update_at,json=updateAt,proto3" json:"update_at,omitempty"`
	// delete_at defines the block number when the object deleted
	DeleteAt int64 `protobuf:"varint,5,opt,name=delete_at,json=deleteAt,proto3" json:"delete_at,omitempty"`
	// delete_reason defines the deleted reason of object
	DeleteReason string `protobuf:"bytes,6,opt,name=delete_reason,json=deleteReason,proto3" json:"delete_reason,omitempty"`
	// operator defines the operator address of object
	Operator string `protobuf:"bytes,7,opt,name=operator,proto3" json:"operator,omitempty"`
	// create_tx_hash defines the creation transaction hash of object
	CreateTxHash string `protobuf:"bytes,8,opt,name=create_tx_hash,json=createTxHash,proto3" json:"create_tx_hash,omitempty"`
	// update_tx_hash defines the update transaction hash of object
	UpdateTxHash string `protobuf:"bytes,9,opt,name=update_tx_hash,json=updateTxHash,proto3" json:"update_tx_hash,omitempty"`
	// seal_tx_hash defines the sealed transaction hash of object
	SealTxHash string `protobuf:"bytes,10,opt,name=seal_tx_hash,json=sealTxHash,proto3" json:"seal_tx_hash,omitempty"`
}

func (m *Object) Reset()         { *m = Object{} }
func (m *Object) String() string { return proto.CompactTextString(m) }
func (*Object) ProtoMessage()    {}
func (*Object) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{1}
}
func (m *Object) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Object) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Object.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Object) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Object.Merge(m, src)
}
func (m *Object) XXX_Size() int {
	return m.Size()
}
func (m *Object) XXX_DiscardUnknown() {
	xxx_messageInfo_Object.DiscardUnknown(m)
}

var xxx_messageInfo_Object proto.InternalMessageInfo

func (m *Object) GetObjectInfo() *types.ObjectInfo {
	if m != nil {
		return m.ObjectInfo
	}
	return nil
}

func (m *Object) GetLockedBalance() string {
	if m != nil {
		return m.LockedBalance
	}
	return ""
}

func (m *Object) GetRemoved() bool {
	if m != nil {
		return m.Removed
	}
	return false
}

func (m *Object) GetUpdateAt() int64 {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

func (m *Object) GetDeleteAt() int64 {
	if m != nil {
		return m.DeleteAt
	}
	return 0
}

func (m *Object) GetDeleteReason() string {
	if m != nil {
		return m.DeleteReason
	}
	return ""
}

func (m *Object) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *Object) GetCreateTxHash() string {
	if m != nil {
		return m.CreateTxHash
	}
	return ""
}

func (m *Object) GetUpdateTxHash() string {
	if m != nil {
		return m.UpdateTxHash
	}
	return ""
}

func (m *Object) GetSealTxHash() string {
	if m != nil {
		return m.SealTxHash
	}
	return ""
}

// GfSpGetUserBucketsRequest is request type for the GfSpGetUserBuckets RPC method.
type GfSpGetUserBucketsRequest struct {
	// account_id is the account address of user
	AccountId string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
}

func (m *GfSpGetUserBucketsRequest) Reset()         { *m = GfSpGetUserBucketsRequest{} }
func (m *GfSpGetUserBucketsRequest) String() string { return proto.CompactTextString(m) }
func (*GfSpGetUserBucketsRequest) ProtoMessage()    {}
func (*GfSpGetUserBucketsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{2}
}
func (m *GfSpGetUserBucketsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetUserBucketsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetUserBucketsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetUserBucketsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetUserBucketsRequest.Merge(m, src)
}
func (m *GfSpGetUserBucketsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetUserBucketsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetUserBucketsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetUserBucketsRequest proto.InternalMessageInfo

func (m *GfSpGetUserBucketsRequest) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

// GfSpGetUserBucketsResponse is response type for the GfSpGetUserBuckets RPC method.
type GfSpGetUserBucketsResponse struct {
	// buckets defines the list of bucket
	Buckets []*Bucket `protobuf:"bytes,1,rep,name=buckets,proto3" json:"buckets,omitempty"`
}

func (m *GfSpGetUserBucketsResponse) Reset()         { *m = GfSpGetUserBucketsResponse{} }
func (m *GfSpGetUserBucketsResponse) String() string { return proto.CompactTextString(m) }
func (*GfSpGetUserBucketsResponse) ProtoMessage()    {}
func (*GfSpGetUserBucketsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{3}
}
func (m *GfSpGetUserBucketsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetUserBucketsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetUserBucketsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetUserBucketsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetUserBucketsResponse.Merge(m, src)
}
func (m *GfSpGetUserBucketsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetUserBucketsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetUserBucketsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetUserBucketsResponse proto.InternalMessageInfo

func (m *GfSpGetUserBucketsResponse) GetBuckets() []*Bucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

// GfSpListObjectsByBucketNameRequest is request type for the GfSpListObjectsByBucketName RPC method
type GfSpListObjectsByBucketNameRequest struct {
	// bucket_name is the name of the bucket
	BucketName string `protobuf:"bytes,1,opt,name=bucket_name,json=bucketName,proto3" json:"bucket_name,omitempty"`
	// account_id is the account address of user
	AccountId string `protobuf:"bytes,2,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	// max_keys sets the maximum number of keys returned in the response
	MaxKeys uint64 `protobuf:"varint,3,opt,name=max_keys,json=maxKeys,proto3" json:"max_keys,omitempty"`
	// start_after is where you want to start listing from
	StartAfter string `protobuf:"bytes,4,opt,name=start_after,json=startAfter,proto3" json:"start_after,omitempty"`
	// continuation_token indicates that the list is being continued on this bucket with a token
	ContinuationToken string `protobuf:"bytes,5,opt,name=continuation_token,json=continuationToken,proto3" json:"continuation_token,omitempty"`
	// delimiter is a character you use to group keys
	Delimiter string `protobuf:"bytes,6,opt,name=delimiter,proto3" json:"delimiter,omitempty"`
	// prefix limits the response to keys that begin with the specified prefix
	Prefix string `protobuf:"bytes,7,opt,name=prefix,proto3" json:"prefix,omitempty"`
}

func (m *GfSpListObjectsByBucketNameRequest) Reset()         { *m = GfSpListObjectsByBucketNameRequest{} }
func (m *GfSpListObjectsByBucketNameRequest) String() string { return proto.CompactTextString(m) }
func (*GfSpListObjectsByBucketNameRequest) ProtoMessage()    {}
func (*GfSpListObjectsByBucketNameRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{4}
}
func (m *GfSpListObjectsByBucketNameRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpListObjectsByBucketNameRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpListObjectsByBucketNameRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpListObjectsByBucketNameRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpListObjectsByBucketNameRequest.Merge(m, src)
}
func (m *GfSpListObjectsByBucketNameRequest) XXX_Size() int {
	return m.Size()
}
func (m *GfSpListObjectsByBucketNameRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpListObjectsByBucketNameRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpListObjectsByBucketNameRequest proto.InternalMessageInfo

func (m *GfSpListObjectsByBucketNameRequest) GetBucketName() string {
	if m != nil {
		return m.BucketName
	}
	return ""
}

func (m *GfSpListObjectsByBucketNameRequest) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *GfSpListObjectsByBucketNameRequest) GetMaxKeys() uint64 {
	if m != nil {
		return m.MaxKeys
	}
	return 0
}

func (m *GfSpListObjectsByBucketNameRequest) GetStartAfter() string {
	if m != nil {
		return m.StartAfter
	}
	return ""
}

func (m *GfSpListObjectsByBucketNameRequest) GetContinuationToken() string {
	if m != nil {
		return m.ContinuationToken
	}
	return ""
}

func (m *GfSpListObjectsByBucketNameRequest) GetDelimiter() string {
	if m != nil {
		return m.Delimiter
	}
	return ""
}

func (m *GfSpListObjectsByBucketNameRequest) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

// GfSpListObjectsByBucketNameResponse is response type for the GfSpListObjectsByBucketName RPC method.
type GfSpListObjectsByBucketNameResponse struct {
	// objects defines the list of object
	Objects []*Object `protobuf:"bytes,1,rep,name=objects,proto3" json:"objects,omitempty"`
	// key_count is the number of keys returned with this request
	KeyCount uint64 `protobuf:"varint,2,opt,name=key_count,json=keyCount,proto3" json:"key_count,omitempty"`
	// max_keys sets the maximum number of keys returned in the response
	MaxKeys uint64 `protobuf:"varint,3,opt,name=max_keys,json=maxKeys,proto3" json:"max_keys,omitempty"`
	// is_truncated set to false if all of the results were returned. set to true if more keys are available to return
	IsTruncated bool `protobuf:"varint,4,opt,name=is_truncated,json=isTruncated,proto3" json:"is_truncated,omitempty"`
	// next_continuation_token is sent when is_truncated is true, which means there are more keys in the bucket that can be listed
	NextContinuationToken string `protobuf:"bytes,5,opt,name=next_continuation_token,json=nextContinuationToken,proto3" json:"next_continuation_token,omitempty"`
	// name of the bucket
	Name string `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	// prefix is the prefix used during the query.
	Prefix string `protobuf:"bytes,7,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// delimiter is the delimiter used during the query
	Delimiter string `protobuf:"bytes,8,opt,name=delimiter,proto3" json:"delimiter,omitempty"`
	// common_prefixes a list of strings representing common prefixes. common_prefixes are those parts of object key names that fall between the specified delimiters
	CommonPrefixes []string `protobuf:"bytes,9,rep,name=common_prefixes,json=commonPrefixes,proto3" json:"common_prefixes,omitempty"`
	// continuationToken is the continuation token used during the query
	ContinuationToken string `protobuf:"bytes,10,opt,name=continuation_token,json=continuationToken,proto3" json:"continuation_token,omitempty"`
}

func (m *GfSpListObjectsByBucketNameResponse) Reset()         { *m = GfSpListObjectsByBucketNameResponse{} }
func (m *GfSpListObjectsByBucketNameResponse) String() string { return proto.CompactTextString(m) }
func (*GfSpListObjectsByBucketNameResponse) ProtoMessage()    {}
func (*GfSpListObjectsByBucketNameResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{5}
}
func (m *GfSpListObjectsByBucketNameResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpListObjectsByBucketNameResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpListObjectsByBucketNameResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpListObjectsByBucketNameResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpListObjectsByBucketNameResponse.Merge(m, src)
}
func (m *GfSpListObjectsByBucketNameResponse) XXX_Size() int {
	return m.Size()
}
func (m *GfSpListObjectsByBucketNameResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpListObjectsByBucketNameResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpListObjectsByBucketNameResponse proto.InternalMessageInfo

func (m *GfSpListObjectsByBucketNameResponse) GetObjects() []*Object {
	if m != nil {
		return m.Objects
	}
	return nil
}

func (m *GfSpListObjectsByBucketNameResponse) GetKeyCount() uint64 {
	if m != nil {
		return m.KeyCount
	}
	return 0
}

func (m *GfSpListObjectsByBucketNameResponse) GetMaxKeys() uint64 {
	if m != nil {
		return m.MaxKeys
	}
	return 0
}

func (m *GfSpListObjectsByBucketNameResponse) GetIsTruncated() bool {
	if m != nil {
		return m.IsTruncated
	}
	return false
}

func (m *GfSpListObjectsByBucketNameResponse) GetNextContinuationToken() string {
	if m != nil {
		return m.NextContinuationToken
	}
	return ""
}

func (m *GfSpListObjectsByBucketNameResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GfSpListObjectsByBucketNameResponse) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *GfSpListObjectsByBucketNameResponse) GetDelimiter() string {
	if m != nil {
		return m.Delimiter
	}
	return ""
}

func (m *GfSpListObjectsByBucketNameResponse) GetCommonPrefixes() []string {
	if m != nil {
		return m.CommonPrefixes
	}
	return nil
}

func (m *GfSpListObjectsByBucketNameResponse) GetContinuationToken() string {
	if m != nil {
		return m.ContinuationToken
	}
	return ""
}

// GfSpGetBucketByBucketNameRequest is request type for the GfSpGetBucketByBucketName RPC method
type GfSpGetBucketByBucketNameRequest struct {
	// bucket_name is the name of the bucket
	BucketName string `protobuf:"bytes,1,opt,name=bucket_name,json=bucketName,proto3" json:"bucket_name,omitempty"`
	// is_full_list indicates whether this request can get the private buckets information
	IsFullList bool `protobuf:"varint,2,opt,name=is_full_list,json=isFullList,proto3" json:"is_full_list,omitempty"`
}

func (m *GfSpGetBucketByBucketNameRequest) Reset()         { *m = GfSpGetBucketByBucketNameRequest{} }
func (m *GfSpGetBucketByBucketNameRequest) String() string { return proto.CompactTextString(m) }
func (*GfSpGetBucketByBucketNameRequest) ProtoMessage()    {}
func (*GfSpGetBucketByBucketNameRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{6}
}
func (m *GfSpGetBucketByBucketNameRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetBucketByBucketNameRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetBucketByBucketNameRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetBucketByBucketNameRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetBucketByBucketNameRequest.Merge(m, src)
}
func (m *GfSpGetBucketByBucketNameRequest) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetBucketByBucketNameRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetBucketByBucketNameRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetBucketByBucketNameRequest proto.InternalMessageInfo

func (m *GfSpGetBucketByBucketNameRequest) GetBucketName() string {
	if m != nil {
		return m.BucketName
	}
	return ""
}

func (m *GfSpGetBucketByBucketNameRequest) GetIsFullList() bool {
	if m != nil {
		return m.IsFullList
	}
	return false
}

// GfSpGetBucketByBucketNameResponse is response type for the GfSpGetBucketByBucketName RPC method.
type GfSpGetBucketByBucketNameResponse struct {
	// bucket defines the information of a bucket
	Bucket *Bucket `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
}

func (m *GfSpGetBucketByBucketNameResponse) Reset()         { *m = GfSpGetBucketByBucketNameResponse{} }
func (m *GfSpGetBucketByBucketNameResponse) String() string { return proto.CompactTextString(m) }
func (*GfSpGetBucketByBucketNameResponse) ProtoMessage()    {}
func (*GfSpGetBucketByBucketNameResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{7}
}
func (m *GfSpGetBucketByBucketNameResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetBucketByBucketNameResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetBucketByBucketNameResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetBucketByBucketNameResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetBucketByBucketNameResponse.Merge(m, src)
}
func (m *GfSpGetBucketByBucketNameResponse) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetBucketByBucketNameResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetBucketByBucketNameResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetBucketByBucketNameResponse proto.InternalMessageInfo

func (m *GfSpGetBucketByBucketNameResponse) GetBucket() *Bucket {
	if m != nil {
		return m.Bucket
	}
	return nil
}

// GfSpGetBucketByBucketIDRequest is request type for the GfSpGetBucketByBucketID RPC method
type GfSpGetBucketByBucketIDRequest struct {
	// bucket_id is the unique identifier of bucket
	BucketId int64 `protobuf:"varint,1,opt,name=bucket_id,json=bucketId,proto3" json:"bucket_id,omitempty"`
	// is_full_list indicates whether this request can get the private buckets information
	IsFullList bool `protobuf:"varint,2,opt,name=is_full_list,json=isFullList,proto3" json:"is_full_list,omitempty"`
}

func (m *GfSpGetBucketByBucketIDRequest) Reset()         { *m = GfSpGetBucketByBucketIDRequest{} }
func (m *GfSpGetBucketByBucketIDRequest) String() string { return proto.CompactTextString(m) }
func (*GfSpGetBucketByBucketIDRequest) ProtoMessage()    {}
func (*GfSpGetBucketByBucketIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{8}
}
func (m *GfSpGetBucketByBucketIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetBucketByBucketIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetBucketByBucketIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetBucketByBucketIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetBucketByBucketIDRequest.Merge(m, src)
}
func (m *GfSpGetBucketByBucketIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetBucketByBucketIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetBucketByBucketIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetBucketByBucketIDRequest proto.InternalMessageInfo

func (m *GfSpGetBucketByBucketIDRequest) GetBucketId() int64 {
	if m != nil {
		return m.BucketId
	}
	return 0
}

func (m *GfSpGetBucketByBucketIDRequest) GetIsFullList() bool {
	if m != nil {
		return m.IsFullList
	}
	return false
}

// GfSpGetBucketByBucketIDResponse is response type for the GfSpGetBucketByBucketID RPC method.
type GfSpGetBucketByBucketIDResponse struct {
	// bucket defines the information of a bucket
	Bucket *Bucket `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
}

func (m *GfSpGetBucketByBucketIDResponse) Reset()         { *m = GfSpGetBucketByBucketIDResponse{} }
func (m *GfSpGetBucketByBucketIDResponse) String() string { return proto.CompactTextString(m) }
func (*GfSpGetBucketByBucketIDResponse) ProtoMessage()    {}
func (*GfSpGetBucketByBucketIDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{9}
}
func (m *GfSpGetBucketByBucketIDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetBucketByBucketIDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetBucketByBucketIDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetBucketByBucketIDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetBucketByBucketIDResponse.Merge(m, src)
}
func (m *GfSpGetBucketByBucketIDResponse) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetBucketByBucketIDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetBucketByBucketIDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetBucketByBucketIDResponse proto.InternalMessageInfo

func (m *GfSpGetBucketByBucketIDResponse) GetBucket() *Bucket {
	if m != nil {
		return m.Bucket
	}
	return nil
}

// GfSpListDeletedObjectsByBlockNumberRangeRequest is request type for the GfSpListDeletedObjectsByBlockNumberRange RPC method
type GfSpListDeletedObjectsByBlockNumberRangeRequest struct {
	// start_block_number defines the start of range
	// [start_block_number, end_block_number], start_block_number > end_block_number is invalid
	StartBlockNumber int64 `protobuf:"varint,1,opt,name=start_block_number,json=startBlockNumber,proto3" json:"start_block_number,omitempty"`
	// end_block_number defines the end of range
	// end_block_number < 0 or start_block_number > end_block_number is invalid
	EndBlockNumber int64 `protobuf:"varint,2,opt,name=end_block_number,json=endBlockNumber,proto3" json:"end_block_number,omitempty"`
	// is_full_list indicates whether this request can get the private objects information
	IsFullList bool `protobuf:"varint,3,opt,name=is_full_list,json=isFullList,proto3" json:"is_full_list,omitempty"`
}

func (m *GfSpListDeletedObjectsByBlockNumberRangeRequest) Reset() {
	*m = GfSpListDeletedObjectsByBlockNumberRangeRequest{}
}
func (m *GfSpListDeletedObjectsByBlockNumberRangeRequest) String() string {
	return proto.CompactTextString(m)
}
func (*GfSpListDeletedObjectsByBlockNumberRangeRequest) ProtoMessage() {}
func (*GfSpListDeletedObjectsByBlockNumberRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{10}
}
func (m *GfSpListDeletedObjectsByBlockNumberRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpListDeletedObjectsByBlockNumberRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpListDeletedObjectsByBlockNumberRangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpListDeletedObjectsByBlockNumberRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpListDeletedObjectsByBlockNumberRangeRequest.Merge(m, src)
}
func (m *GfSpListDeletedObjectsByBlockNumberRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *GfSpListDeletedObjectsByBlockNumberRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpListDeletedObjectsByBlockNumberRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpListDeletedObjectsByBlockNumberRangeRequest proto.InternalMessageInfo

func (m *GfSpListDeletedObjectsByBlockNumberRangeRequest) GetStartBlockNumber() int64 {
	if m != nil {
		return m.StartBlockNumber
	}
	return 0
}

func (m *GfSpListDeletedObjectsByBlockNumberRangeRequest) GetEndBlockNumber() int64 {
	if m != nil {
		return m.EndBlockNumber
	}
	return 0
}

func (m *GfSpListDeletedObjectsByBlockNumberRangeRequest) GetIsFullList() bool {
	if m != nil {
		return m.IsFullList
	}
	return false
}

// GfSpListDeletedObjectsByBlockNumberRangeResponse is response type for the GfSpListDeletedObjectsByBlockNumberRange RPC method.
type GfSpListDeletedObjectsByBlockNumberRangeResponse struct {
	// objects defines the list of object
	Objects []*Object `protobuf:"bytes,1,rep,name=objects,proto3" json:"objects,omitempty"`
	// latest_block_number defines the response objects latest block number
	EndBlockNumber int64 `protobuf:"varint,2,opt,name=end_block_number,json=endBlockNumber,proto3" json:"end_block_number,omitempty"`
}

func (m *GfSpListDeletedObjectsByBlockNumberRangeResponse) Reset() {
	*m = GfSpListDeletedObjectsByBlockNumberRangeResponse{}
}
func (m *GfSpListDeletedObjectsByBlockNumberRangeResponse) String() string {
	return proto.CompactTextString(m)
}
func (*GfSpListDeletedObjectsByBlockNumberRangeResponse) ProtoMessage() {}
func (*GfSpListDeletedObjectsByBlockNumberRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{11}
}
func (m *GfSpListDeletedObjectsByBlockNumberRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpListDeletedObjectsByBlockNumberRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpListDeletedObjectsByBlockNumberRangeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpListDeletedObjectsByBlockNumberRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpListDeletedObjectsByBlockNumberRangeResponse.Merge(m, src)
}
func (m *GfSpListDeletedObjectsByBlockNumberRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *GfSpListDeletedObjectsByBlockNumberRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpListDeletedObjectsByBlockNumberRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpListDeletedObjectsByBlockNumberRangeResponse proto.InternalMessageInfo

func (m *GfSpListDeletedObjectsByBlockNumberRangeResponse) GetObjects() []*Object {
	if m != nil {
		return m.Objects
	}
	return nil
}

func (m *GfSpListDeletedObjectsByBlockNumberRangeResponse) GetEndBlockNumber() int64 {
	if m != nil {
		return m.EndBlockNumber
	}
	return 0
}

// GfSpGetUserBucketsCountRequest is request type for the GfSpGetUserBucketsCount RPC method.
type GfSpGetUserBucketsCountRequest struct {
	// account_id is the account address of user
	AccountId string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
}

func (m *GfSpGetUserBucketsCountRequest) Reset()         { *m = GfSpGetUserBucketsCountRequest{} }
func (m *GfSpGetUserBucketsCountRequest) String() string { return proto.CompactTextString(m) }
func (*GfSpGetUserBucketsCountRequest) ProtoMessage()    {}
func (*GfSpGetUserBucketsCountRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{12}
}
func (m *GfSpGetUserBucketsCountRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetUserBucketsCountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetUserBucketsCountRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetUserBucketsCountRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetUserBucketsCountRequest.Merge(m, src)
}
func (m *GfSpGetUserBucketsCountRequest) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetUserBucketsCountRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetUserBucketsCountRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetUserBucketsCountRequest proto.InternalMessageInfo

func (m *GfSpGetUserBucketsCountRequest) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

// GfSpGetUserBucketsCountResponse is response type for the GfSpGetUserBucketsCount RPC method.
type GfSpGetUserBucketsCountResponse struct {
	// count defines total count of user buckets
	Count int64 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *GfSpGetUserBucketsCountResponse) Reset()         { *m = GfSpGetUserBucketsCountResponse{} }
func (m *GfSpGetUserBucketsCountResponse) String() string { return proto.CompactTextString(m) }
func (*GfSpGetUserBucketsCountResponse) ProtoMessage()    {}
func (*GfSpGetUserBucketsCountResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{13}
}
func (m *GfSpGetUserBucketsCountResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetUserBucketsCountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetUserBucketsCountResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetUserBucketsCountResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetUserBucketsCountResponse.Merge(m, src)
}
func (m *GfSpGetUserBucketsCountResponse) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetUserBucketsCountResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetUserBucketsCountResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetUserBucketsCountResponse proto.InternalMessageInfo

func (m *GfSpGetUserBucketsCountResponse) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

// GfSpListExpiredBucketsBySpRequest is the request type for the GfSpListExpiredBucketsBySp RPC method.
type GfSpListExpiredBucketsBySpRequest struct {
	// create_at defines the create timestamp of bucket
	CreateAt int64 `protobuf:"varint,1,opt,name=create_at,json=createAt,proto3" json:"create_at,omitempty"`
	// primary_sp_address defines the primary sp address of bucket
	PrimarySpAddress string `protobuf:"bytes,2,opt,name=primary_sp_address,json=primarySpAddress,proto3" json:"primary_sp_address,omitempty"`
	// limit defines the return number limit of bucket
	Limit int64 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *GfSpListExpiredBucketsBySpRequest) Reset()         { *m = GfSpListExpiredBucketsBySpRequest{} }
func (m *GfSpListExpiredBucketsBySpRequest) String() string { return proto.CompactTextString(m) }
func (*GfSpListExpiredBucketsBySpRequest) ProtoMessage()    {}
func (*GfSpListExpiredBucketsBySpRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{14}
}
func (m *GfSpListExpiredBucketsBySpRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpListExpiredBucketsBySpRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpListExpiredBucketsBySpRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpListExpiredBucketsBySpRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpListExpiredBucketsBySpRequest.Merge(m, src)
}
func (m *GfSpListExpiredBucketsBySpRequest) XXX_Size() int {
	return m.Size()
}
func (m *GfSpListExpiredBucketsBySpRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpListExpiredBucketsBySpRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpListExpiredBucketsBySpRequest proto.InternalMessageInfo

func (m *GfSpListExpiredBucketsBySpRequest) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *GfSpListExpiredBucketsBySpRequest) GetPrimarySpAddress() string {
	if m != nil {
		return m.PrimarySpAddress
	}
	return ""
}

func (m *GfSpListExpiredBucketsBySpRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// GfSpListExpiredBucketsBySpResponse is the response type for the GfSpListExpiredBucketsBySp RPC method.
type GfSpListExpiredBucketsBySpResponse struct {
	// buckets defines the list of expired bucket
	Buckets []*Bucket `protobuf:"bytes,1,rep,name=buckets,proto3" json:"buckets,omitempty"`
}

func (m *GfSpListExpiredBucketsBySpResponse) Reset()         { *m = GfSpListExpiredBucketsBySpResponse{} }
func (m *GfSpListExpiredBucketsBySpResponse) String() string { return proto.CompactTextString(m) }
func (*GfSpListExpiredBucketsBySpResponse) ProtoMessage()    {}
func (*GfSpListExpiredBucketsBySpResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{15}
}
func (m *GfSpListExpiredBucketsBySpResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpListExpiredBucketsBySpResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpListExpiredBucketsBySpResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpListExpiredBucketsBySpResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpListExpiredBucketsBySpResponse.Merge(m, src)
}
func (m *GfSpListExpiredBucketsBySpResponse) XXX_Size() int {
	return m.Size()
}
func (m *GfSpListExpiredBucketsBySpResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpListExpiredBucketsBySpResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpListExpiredBucketsBySpResponse proto.InternalMessageInfo

func (m *GfSpListExpiredBucketsBySpResponse) GetBuckets() []*Bucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

// GfSpGetObjectMetaRequest is request type for the GfSpGetObjectMeta RPC method
type GfSpGetObjectMetaRequest struct {
	// object_name is the name of the object
	ObjectName string `protobuf:"bytes,1,opt,name=object_name,json=objectName,proto3" json:"object_name,omitempty"`
	// bucket_name is the name of the bucket
	BucketName string `protobuf:"bytes,2,opt,name=bucket_name,json=bucketName,proto3" json:"bucket_name,omitempty"`
	// is_full_list indicates whether this request can get the private objects information
	IsFullList bool `protobuf:"varint,3,opt,name=is_full_list,json=isFullList,proto3" json:"is_full_list,omitempty"`
}

func (m *GfSpGetObjectMetaRequest) Reset()         { *m = GfSpGetObjectMetaRequest{} }
func (m *GfSpGetObjectMetaRequest) String() string { return proto.CompactTextString(m) }
func (*GfSpGetObjectMetaRequest) ProtoMessage()    {}
func (*GfSpGetObjectMetaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{16}
}
func (m *GfSpGetObjectMetaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetObjectMetaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetObjectMetaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetObjectMetaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetObjectMetaRequest.Merge(m, src)
}
func (m *GfSpGetObjectMetaRequest) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetObjectMetaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetObjectMetaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetObjectMetaRequest proto.InternalMessageInfo

func (m *GfSpGetObjectMetaRequest) GetObjectName() string {
	if m != nil {
		return m.ObjectName
	}
	return ""
}

func (m *GfSpGetObjectMetaRequest) GetBucketName() string {
	if m != nil {
		return m.BucketName
	}
	return ""
}

func (m *GfSpGetObjectMetaRequest) GetIsFullList() bool {
	if m != nil {
		return m.IsFullList
	}
	return false
}

// GfSpGetObjectMetaResponse is response type for the GfSpGetObjectMeta RPC method.
type GfSpGetObjectMetaResponse struct {
	// object defines the information of an object
	Object *Object `protobuf:"bytes,1,opt,name=object,proto3" json:"object,omitempty"`
}

func (m *GfSpGetObjectMetaResponse) Reset()         { *m = GfSpGetObjectMetaResponse{} }
func (m *GfSpGetObjectMetaResponse) String() string { return proto.CompactTextString(m) }
func (*GfSpGetObjectMetaResponse) ProtoMessage()    {}
func (*GfSpGetObjectMetaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{17}
}
func (m *GfSpGetObjectMetaResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetObjectMetaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetObjectMetaResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetObjectMetaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetObjectMetaResponse.Merge(m, src)
}
func (m *GfSpGetObjectMetaResponse) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetObjectMetaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetObjectMetaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetObjectMetaResponse proto.InternalMessageInfo

func (m *GfSpGetObjectMetaResponse) GetObject() *Object {
	if m != nil {
		return m.Object
	}
	return nil
}

// GfSpGetPaymentByBucketNameRequest is request type for the GfSpGetPaymentByBucketName RPC method
type GfSpGetPaymentByBucketNameRequest struct {
	// bucket_name is the name of the bucket
	BucketName string `protobuf:"bytes,1,opt,name=bucket_name,json=bucketName,proto3" json:"bucket_name,omitempty"`
	// is_full_list indicates whether this request can get the private buckets information
	IsFullList bool `protobuf:"varint,2,opt,name=is_full_list,json=isFullList,proto3" json:"is_full_list,omitempty"`
}

func (m *GfSpGetPaymentByBucketNameRequest) Reset()         { *m = GfSpGetPaymentByBucketNameRequest{} }
func (m *GfSpGetPaymentByBucketNameRequest) String() string { return proto.CompactTextString(m) }
func (*GfSpGetPaymentByBucketNameRequest) ProtoMessage()    {}
func (*GfSpGetPaymentByBucketNameRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{18}
}
func (m *GfSpGetPaymentByBucketNameRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetPaymentByBucketNameRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetPaymentByBucketNameRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetPaymentByBucketNameRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetPaymentByBucketNameRequest.Merge(m, src)
}
func (m *GfSpGetPaymentByBucketNameRequest) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetPaymentByBucketNameRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetPaymentByBucketNameRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetPaymentByBucketNameRequest proto.InternalMessageInfo

func (m *GfSpGetPaymentByBucketNameRequest) GetBucketName() string {
	if m != nil {
		return m.BucketName
	}
	return ""
}

func (m *GfSpGetPaymentByBucketNameRequest) GetIsFullList() bool {
	if m != nil {
		return m.IsFullList
	}
	return false
}

// GfSpGetPaymentByBucketNameResponse is response type for the GfSpGetPaymentByBucketName RPC method.
type GfSpGetPaymentByBucketNameResponse struct {
	// stream_record defines stream payment record of a stream account
	StreamRecord *types1.StreamRecord `protobuf:"bytes,1,opt,name=stream_record,json=streamRecord,proto3" json:"stream_record,omitempty"`
}

func (m *GfSpGetPaymentByBucketNameResponse) Reset()         { *m = GfSpGetPaymentByBucketNameResponse{} }
func (m *GfSpGetPaymentByBucketNameResponse) String() string { return proto.CompactTextString(m) }
func (*GfSpGetPaymentByBucketNameResponse) ProtoMessage()    {}
func (*GfSpGetPaymentByBucketNameResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{19}
}
func (m *GfSpGetPaymentByBucketNameResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetPaymentByBucketNameResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetPaymentByBucketNameResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetPaymentByBucketNameResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetPaymentByBucketNameResponse.Merge(m, src)
}
func (m *GfSpGetPaymentByBucketNameResponse) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetPaymentByBucketNameResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetPaymentByBucketNameResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetPaymentByBucketNameResponse proto.InternalMessageInfo

func (m *GfSpGetPaymentByBucketNameResponse) GetStreamRecord() *types1.StreamRecord {
	if m != nil {
		return m.StreamRecord
	}
	return nil
}

// GfSpGetPaymentByBucketIDRequest is request type for the GfSpGetPaymentByBucketID RPC method
type GfSpGetPaymentByBucketIDRequest struct {
	// bucket_id is the unique identifier of bucket
	BucketId int64 `protobuf:"varint,1,opt,name=bucket_id,json=bucketId,proto3" json:"bucket_id,omitempty"`
	// is_full_list indicates whether this request can get the private buckets information
	IsFullList bool `protobuf:"varint,2,opt,name=is_full_list,json=isFullList,proto3" json:"is_full_list,omitempty"`
}

func (m *GfSpGetPaymentByBucketIDRequest) Reset()         { *m = GfSpGetPaymentByBucketIDRequest{} }
func (m *GfSpGetPaymentByBucketIDRequest) String() string { return proto.CompactTextString(m) }
func (*GfSpGetPaymentByBucketIDRequest) ProtoMessage()    {}
func (*GfSpGetPaymentByBucketIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{20}
}
func (m *GfSpGetPaymentByBucketIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetPaymentByBucketIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetPaymentByBucketIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetPaymentByBucketIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetPaymentByBucketIDRequest.Merge(m, src)
}
func (m *GfSpGetPaymentByBucketIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetPaymentByBucketIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetPaymentByBucketIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetPaymentByBucketIDRequest proto.InternalMessageInfo

func (m *GfSpGetPaymentByBucketIDRequest) GetBucketId() int64 {
	if m != nil {
		return m.BucketId
	}
	return 0
}

func (m *GfSpGetPaymentByBucketIDRequest) GetIsFullList() bool {
	if m != nil {
		return m.IsFullList
	}
	return false
}

// GfSpGetPaymentByBucketIDResponse is response type for the GfSpGetPaymentByBucketID RPC method.
type GfSpGetPaymentByBucketIDResponse struct {
	// stream_record defines stream payment record of a stream account
	StreamRecord *types1.StreamRecord `protobuf:"bytes,1,opt,name=stream_record,json=streamRecord,proto3" json:"stream_record,omitempty"`
}

func (m *GfSpGetPaymentByBucketIDResponse) Reset()         { *m = GfSpGetPaymentByBucketIDResponse{} }
func (m *GfSpGetPaymentByBucketIDResponse) String() string { return proto.CompactTextString(m) }
func (*GfSpGetPaymentByBucketIDResponse) ProtoMessage()    {}
func (*GfSpGetPaymentByBucketIDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{21}
}
func (m *GfSpGetPaymentByBucketIDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetPaymentByBucketIDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetPaymentByBucketIDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetPaymentByBucketIDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetPaymentByBucketIDResponse.Merge(m, src)
}
func (m *GfSpGetPaymentByBucketIDResponse) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetPaymentByBucketIDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetPaymentByBucketIDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetPaymentByBucketIDResponse proto.InternalMessageInfo

func (m *GfSpGetPaymentByBucketIDResponse) GetStreamRecord() *types1.StreamRecord {
	if m != nil {
		return m.StreamRecord
	}
	return nil
}

// GfSpGetBucketMetaRequest is request type for the GfSpGetBucketMeta RPC method
type GfSpGetBucketMetaRequest struct {
	// bucket_name is the name of the bucket
	BucketName string `protobuf:"bytes,1,opt,name=bucket_name,json=bucketName,proto3" json:"bucket_name,omitempty"`
	// is_full_list indicates whether this request can get the private buckets information
	IsFullList bool `protobuf:"varint,2,opt,name=is_full_list,json=isFullList,proto3" json:"is_full_list,omitempty"`
}

func (m *GfSpGetBucketMetaRequest) Reset()         { *m = GfSpGetBucketMetaRequest{} }
func (m *GfSpGetBucketMetaRequest) String() string { return proto.CompactTextString(m) }
func (*GfSpGetBucketMetaRequest) ProtoMessage()    {}
func (*GfSpGetBucketMetaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{22}
}
func (m *GfSpGetBucketMetaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetBucketMetaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetBucketMetaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetBucketMetaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetBucketMetaRequest.Merge(m, src)
}
func (m *GfSpGetBucketMetaRequest) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetBucketMetaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetBucketMetaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetBucketMetaRequest proto.InternalMessageInfo

func (m *GfSpGetBucketMetaRequest) GetBucketName() string {
	if m != nil {
		return m.BucketName
	}
	return ""
}

func (m *GfSpGetBucketMetaRequest) GetIsFullList() bool {
	if m != nil {
		return m.IsFullList
	}
	return false
}

// GfSpGetBucketMetaResponse is response type for the GfSpGetBucketMeta RPC method
type GfSpGetBucketMetaResponse struct {
	// bucket defines the information of a bucket
	Bucket *Bucket `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	// stream_record defines stream payment record of a stream account
	StreamRecord *types1.StreamRecord `protobuf:"bytes,2,opt,name=stream_record,json=streamRecord,proto3" json:"stream_record,omitempty"`
}

func (m *GfSpGetBucketMetaResponse) Reset()         { *m = GfSpGetBucketMetaResponse{} }
func (m *GfSpGetBucketMetaResponse) String() string { return proto.CompactTextString(m) }
func (*GfSpGetBucketMetaResponse) ProtoMessage()    {}
func (*GfSpGetBucketMetaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{23}
}
func (m *GfSpGetBucketMetaResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetBucketMetaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetBucketMetaResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetBucketMetaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetBucketMetaResponse.Merge(m, src)
}
func (m *GfSpGetBucketMetaResponse) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetBucketMetaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetBucketMetaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetBucketMetaResponse proto.InternalMessageInfo

func (m *GfSpGetBucketMetaResponse) GetBucket() *Bucket {
	if m != nil {
		return m.Bucket
	}
	return nil
}

func (m *GfSpGetBucketMetaResponse) GetStreamRecord() *types1.StreamRecord {
	if m != nil {
		return m.StreamRecord
	}
	return nil
}

// GfSpGetEndpointBySpAddressRequest is request type for the GfSpGetEndpointBySpAddress RPC method
type GfSpGetEndpointBySpAddressRequest struct {
	// sp_address is the address of the sp
	SpAddress string `protobuf:"bytes,1,opt,name=sp_address,json=spAddress,proto3" json:"sp_address,omitempty"`
}

func (m *GfSpGetEndpointBySpAddressRequest) Reset()         { *m = GfSpGetEndpointBySpAddressRequest{} }
func (m *GfSpGetEndpointBySpAddressRequest) String() string { return proto.CompactTextString(m) }
func (*GfSpGetEndpointBySpAddressRequest) ProtoMessage()    {}
func (*GfSpGetEndpointBySpAddressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{24}
}
func (m *GfSpGetEndpointBySpAddressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetEndpointBySpAddressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetEndpointBySpAddressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetEndpointBySpAddressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetEndpointBySpAddressRequest.Merge(m, src)
}
func (m *GfSpGetEndpointBySpAddressRequest) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetEndpointBySpAddressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetEndpointBySpAddressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetEndpointBySpAddressRequest proto.InternalMessageInfo

func (m *GfSpGetEndpointBySpAddressRequest) GetSpAddress() string {
	if m != nil {
		return m.SpAddress
	}
	return ""
}

// GfSpGetEndpointBySpAddressResponse is response type for the GfSpGetEndpointBySpAddress RPC method.
type GfSpGetEndpointBySpAddressResponse struct {
	// endpoint defines endpoint of a sp
	Endpoint string `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
}

func (m *GfSpGetEndpointBySpAddressResponse) Reset()         { *m = GfSpGetEndpointBySpAddressResponse{} }
func (m *GfSpGetEndpointBySpAddressResponse) String() string { return proto.CompactTextString(m) }
func (*GfSpGetEndpointBySpAddressResponse) ProtoMessage()    {}
func (*GfSpGetEndpointBySpAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{25}
}
func (m *GfSpGetEndpointBySpAddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetEndpointBySpAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetEndpointBySpAddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetEndpointBySpAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetEndpointBySpAddressResponse.Merge(m, src)
}
func (m *GfSpGetEndpointBySpAddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetEndpointBySpAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetEndpointBySpAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetEndpointBySpAddressResponse proto.InternalMessageInfo

func (m *GfSpGetEndpointBySpAddressResponse) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

// GfSpGetBucketReadQuotaRequest is request type for the GfSpGetBucketReadQuota RPC method.
type GfSpGetBucketReadQuotaRequest struct {
	// bucket info from the greenfield chain
	BucketInfo *types.BucketInfo `protobuf:"bytes,1,opt,name=bucket_info,json=bucketInfo,proto3" json:"bucket_info,omitempty"`
	// year_month is the query bucket quota's month, like "2023-03"
	YearMonth string `protobuf:"bytes,2,opt,name=year_month,json=yearMonth,proto3" json:"year_month,omitempty"`
}

func (m *GfSpGetBucketReadQuotaRequest) Reset()         { *m = GfSpGetBucketReadQuotaRequest{} }
func (m *GfSpGetBucketReadQuotaRequest) String() string { return proto.CompactTextString(m) }
func (*GfSpGetBucketReadQuotaRequest) ProtoMessage()    {}
func (*GfSpGetBucketReadQuotaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{26}
}
func (m *GfSpGetBucketReadQuotaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetBucketReadQuotaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetBucketReadQuotaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetBucketReadQuotaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetBucketReadQuotaRequest.Merge(m, src)
}
func (m *GfSpGetBucketReadQuotaRequest) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetBucketReadQuotaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetBucketReadQuotaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetBucketReadQuotaRequest proto.InternalMessageInfo

func (m *GfSpGetBucketReadQuotaRequest) GetBucketInfo() *types.BucketInfo {
	if m != nil {
		return m.BucketInfo
	}
	return nil
}

func (m *GfSpGetBucketReadQuotaRequest) GetYearMonth() string {
	if m != nil {
		return m.YearMonth
	}
	return ""
}

// GfSpGetBucketReadQuotaResponse is response type for the GfSpGetBucketReadQuota RPC method.
type GfSpGetBucketReadQuotaResponse struct {
	Err *gfsperrors.GfSpError `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	// charged_quota_size is the greenfield chain bucket info's read quota size
	ChargedQuotaSize uint64 `protobuf:"varint,2,opt,name=charged_quota_size,json=chargedQuotaSize,proto3" json:"charged_quota_size,omitempty"`
	// sp_free_quota_size is the sp default free quota
	SpFreeQuotaSize uint64 `protobuf:"varint,3,opt,name=sp_free_quota_size,json=spFreeQuotaSize,proto3" json:"sp_free_quota_size,omitempty"`
	// consumed_size is currently consumed size
	ConsumedSize uint64 `protobuf:"varint,4,opt,name=consumed_size,json=consumedSize,proto3" json:"consumed_size,omitempty"`
}

func (m *GfSpGetBucketReadQuotaResponse) Reset()         { *m = GfSpGetBucketReadQuotaResponse{} }
func (m *GfSpGetBucketReadQuotaResponse) String() string { return proto.CompactTextString(m) }
func (*GfSpGetBucketReadQuotaResponse) ProtoMessage()    {}
func (*GfSpGetBucketReadQuotaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{27}
}
func (m *GfSpGetBucketReadQuotaResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpGetBucketReadQuotaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpGetBucketReadQuotaResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpGetBucketReadQuotaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpGetBucketReadQuotaResponse.Merge(m, src)
}
func (m *GfSpGetBucketReadQuotaResponse) XXX_Size() int {
	return m.Size()
}
func (m *GfSpGetBucketReadQuotaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpGetBucketReadQuotaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpGetBucketReadQuotaResponse proto.InternalMessageInfo

func (m *GfSpGetBucketReadQuotaResponse) GetErr() *gfsperrors.GfSpError {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GfSpGetBucketReadQuotaResponse) GetChargedQuotaSize() uint64 {
	if m != nil {
		return m.ChargedQuotaSize
	}
	return 0
}

func (m *GfSpGetBucketReadQuotaResponse) GetSpFreeQuotaSize() uint64 {
	if m != nil {
		return m.SpFreeQuotaSize
	}
	return 0
}

func (m *GfSpGetBucketReadQuotaResponse) GetConsumedSize() uint64 {
	if m != nil {
		return m.ConsumedSize
	}
	return 0
}

// ListBucketReadRecordRequest is request type for the ListBucketReadRecord RPC method.
type GfSpListBucketReadRecordRequest struct {
	// bucket info from the greenfield chain
	BucketInfo *types.BucketInfo `protobuf:"bytes,1,opt,name=bucket_info,json=bucketInfo,proto3" json:"bucket_info,omitempty"`
	// start_timestamp_us is the list request's left side, like [start_timestamp_us, end_timestamp_us)
	StartTimestampUs int64 `protobuf:"varint,2,opt,name=start_timestamp_us,json=startTimestampUs,proto3" json:"start_timestamp_us,omitempty"`
	// start_timestamp_us is the list request's right side, like [start_timestamp_us, end_timestamp_us)
	EndTimestampUs int64 `protobuf:"varint,3,opt,name=end_timestamp_us,json=endTimestampUs,proto3" json:"end_timestamp_us,omitempty"`
	// max_record_num is used to limit max list records
	MaxRecordNum int64 `protobuf:"varint,4,opt,name=max_record_num,json=maxRecordNum,proto3" json:"max_record_num,omitempty"`
}

func (m *GfSpListBucketReadRecordRequest) Reset()         { *m = GfSpListBucketReadRecordRequest{} }
func (m *GfSpListBucketReadRecordRequest) String() string { return proto.CompactTextString(m) }
func (*GfSpListBucketReadRecordRequest) ProtoMessage()    {}
func (*GfSpListBucketReadRecordRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{28}
}
func (m *GfSpListBucketReadRecordRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpListBucketReadRecordRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpListBucketReadRecordRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpListBucketReadRecordRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpListBucketReadRecordRequest.Merge(m, src)
}
func (m *GfSpListBucketReadRecordRequest) XXX_Size() int {
	return m.Size()
}
func (m *GfSpListBucketReadRecordRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpListBucketReadRecordRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpListBucketReadRecordRequest proto.InternalMessageInfo

func (m *GfSpListBucketReadRecordRequest) GetBucketInfo() *types.BucketInfo {
	if m != nil {
		return m.BucketInfo
	}
	return nil
}

func (m *GfSpListBucketReadRecordRequest) GetStartTimestampUs() int64 {
	if m != nil {
		return m.StartTimestampUs
	}
	return 0
}

func (m *GfSpListBucketReadRecordRequest) GetEndTimestampUs() int64 {
	if m != nil {
		return m.EndTimestampUs
	}
	return 0
}

func (m *GfSpListBucketReadRecordRequest) GetMaxRecordNum() int64 {
	if m != nil {
		return m.MaxRecordNum
	}
	return 0
}

// ReadRecord is used to record the read request.
type ReadRecord struct {
	// object_name is the read object name
	ObjectName string `protobuf:"bytes,1,opt,name=object_name,json=objectName,proto3" json:"object_name,omitempty"`
	// object_id is the read object id
	ObjectId uint64 `protobuf:"varint,2,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	// account_address is the read account address
	AccountAddress string `protobuf:"bytes,3,opt,name=account_address,json=accountAddress,proto3" json:"account_address,omitempty"`
	// timestamp_us is the read time stamp
	TimestampUs int64 `protobuf:"varint,4,opt,name=timestamp_us,json=timestampUs,proto3" json:"timestamp_us,omitempty"`
	// read_size is the read object size
	ReadSize uint64 `protobuf:"varint,5,opt,name=read_size,json=readSize,proto3" json:"read_size,omitempty"`
}

func (m *ReadRecord) Reset()         { *m = ReadRecord{} }
func (m *ReadRecord) String() string { return proto.CompactTextString(m) }
func (*ReadRecord) ProtoMessage()    {}
func (*ReadRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{29}
}
func (m *ReadRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadRecord.Merge(m, src)
}
func (m *ReadRecord) XXX_Size() int {
	return m.Size()
}
func (m *ReadRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadRecord.DiscardUnknown(m)
}

var xxx_messageInfo_ReadRecord proto.InternalMessageInfo

func (m *ReadRecord) GetObjectName() string {
	if m != nil {
		return m.ObjectName
	}
	return ""
}

func (m *ReadRecord) GetObjectId() uint64 {
	if m != nil {
		return m.ObjectId
	}
	return 0
}

func (m *ReadRecord) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *ReadRecord) GetTimestampUs() int64 {
	if m != nil {
		return m.TimestampUs
	}
	return 0
}

func (m *ReadRecord) GetReadSize() uint64 {
	if m != nil {
		return m.ReadSize
	}
	return 0
}

// ListBucketReadRecordResponse is response type for the ListBucketReadRecord RPC method.
type GfSpListBucketReadRecordResponse struct {
	Err *gfsperrors.GfSpError `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	// read_records are the read record list
	ReadRecords []*ReadRecord `protobuf:"bytes,2,rep,name=read_records,json=readRecords,proto3" json:"read_records,omitempty"`
	// next_start_timestamp_us is used to fetch next batch, When the list is completed, it is 0.
	NextStartTimestampUs int64 `protobuf:"varint,3,opt,name=next_start_timestamp_us,json=nextStartTimestampUs,proto3" json:"next_start_timestamp_us,omitempty"`
}

func (m *GfSpListBucketReadRecordResponse) Reset()         { *m = GfSpListBucketReadRecordResponse{} }
func (m *GfSpListBucketReadRecordResponse) String() string { return proto.CompactTextString(m) }
func (*GfSpListBucketReadRecordResponse) ProtoMessage()    {}
func (*GfSpListBucketReadRecordResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{30}
}
func (m *GfSpListBucketReadRecordResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpListBucketReadRecordResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpListBucketReadRecordResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpListBucketReadRecordResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpListBucketReadRecordResponse.Merge(m, src)
}
func (m *GfSpListBucketReadRecordResponse) XXX_Size() int {
	return m.Size()
}
func (m *GfSpListBucketReadRecordResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpListBucketReadRecordResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpListBucketReadRecordResponse proto.InternalMessageInfo

func (m *GfSpListBucketReadRecordResponse) GetErr() *gfsperrors.GfSpError {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GfSpListBucketReadRecordResponse) GetReadRecords() []*ReadRecord {
	if m != nil {
		return m.ReadRecords
	}
	return nil
}

func (m *GfSpListBucketReadRecordResponse) GetNextStartTimestampUs() int64 {
	if m != nil {
		return m.NextStartTimestampUs
	}
	return 0
}

// QueryUploadProgressRequest is request type for the QueryObjectPutState RPC method.
type GfSpQueryUploadProgressRequest struct {
	// object_id defines the unique id of the object.
	ObjectId uint64 `protobuf:"varint,1,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
}

func (m *GfSpQueryUploadProgressRequest) Reset()         { *m = GfSpQueryUploadProgressRequest{} }
func (m *GfSpQueryUploadProgressRequest) String() string { return proto.CompactTextString(m) }
func (*GfSpQueryUploadProgressRequest) ProtoMessage()    {}
func (*GfSpQueryUploadProgressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{31}
}
func (m *GfSpQueryUploadProgressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpQueryUploadProgressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpQueryUploadProgressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpQueryUploadProgressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpQueryUploadProgressRequest.Merge(m, src)
}
func (m *GfSpQueryUploadProgressRequest) XXX_Size() int {
	return m.Size()
}
func (m *GfSpQueryUploadProgressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpQueryUploadProgressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpQueryUploadProgressRequest proto.InternalMessageInfo

func (m *GfSpQueryUploadProgressRequest) GetObjectId() uint64 {
	if m != nil {
		return m.ObjectId
	}
	return 0
}

// QueryUploadProgressResponse is response type for the QueryObjectPutState RPC method.
type GfSpQueryUploadProgressResponse struct {
	Err *gfsperrors.GfSpError `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	// state defines the state of put object.
	State types2.JobState `protobuf:"varint,2,opt,name=state,proto3,enum=service.types.JobState" json:"state,omitempty"`
}

func (m *GfSpQueryUploadProgressResponse) Reset()         { *m = GfSpQueryUploadProgressResponse{} }
func (m *GfSpQueryUploadProgressResponse) String() string { return proto.CompactTextString(m) }
func (*GfSpQueryUploadProgressResponse) ProtoMessage()    {}
func (*GfSpQueryUploadProgressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cdcff708e247f22, []int{32}
}
func (m *GfSpQueryUploadProgressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GfSpQueryUploadProgressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GfSpQueryUploadProgressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GfSpQueryUploadProgressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GfSpQueryUploadProgressResponse.Merge(m, src)
}
func (m *GfSpQueryUploadProgressResponse) XXX_Size() int {
	return m.Size()
}
func (m *GfSpQueryUploadProgressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GfSpQueryUploadProgressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GfSpQueryUploadProgressResponse proto.InternalMessageInfo

func (m *GfSpQueryUploadProgressResponse) GetErr() *gfsperrors.GfSpError {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GfSpQueryUploadProgressResponse) GetState() types2.JobState {
	if m != nil {
		return m.State
	}
	return types2.JobState_JOB_STATE_INIT_UNSPECIFIED
}

func init() {
	proto.RegisterType((*Bucket)(nil), "modular.metadata.types.Bucket")
	proto.RegisterType((*Object)(nil), "modular.metadata.types.Object")
	proto.RegisterType((*GfSpGetUserBucketsRequest)(nil), "modular.metadata.types.GfSpGetUserBucketsRequest")
	proto.RegisterType((*GfSpGetUserBucketsResponse)(nil), "modular.metadata.types.GfSpGetUserBucketsResponse")
	proto.RegisterType((*GfSpListObjectsByBucketNameRequest)(nil), "modular.metadata.types.GfSpListObjectsByBucketNameRequest")
	proto.RegisterType((*GfSpListObjectsByBucketNameResponse)(nil), "modular.metadata.types.GfSpListObjectsByBucketNameResponse")
	proto.RegisterType((*GfSpGetBucketByBucketNameRequest)(nil), "modular.metadata.types.GfSpGetBucketByBucketNameRequest")
	proto.RegisterType((*GfSpGetBucketByBucketNameResponse)(nil), "modular.metadata.types.GfSpGetBucketByBucketNameResponse")
	proto.RegisterType((*GfSpGetBucketByBucketIDRequest)(nil), "modular.metadata.types.GfSpGetBucketByBucketIDRequest")
	proto.RegisterType((*GfSpGetBucketByBucketIDResponse)(nil), "modular.metadata.types.GfSpGetBucketByBucketIDResponse")
	proto.RegisterType((*GfSpListDeletedObjectsByBlockNumberRangeRequest)(nil), "modular.metadata.types.GfSpListDeletedObjectsByBlockNumberRangeRequest")
	proto.RegisterType((*GfSpListDeletedObjectsByBlockNumberRangeResponse)(nil), "modular.metadata.types.GfSpListDeletedObjectsByBlockNumberRangeResponse")
	proto.RegisterType((*GfSpGetUserBucketsCountRequest)(nil), "modular.metadata.types.GfSpGetUserBucketsCountRequest")
	proto.RegisterType((*GfSpGetUserBucketsCountResponse)(nil), "modular.metadata.types.GfSpGetUserBucketsCountResponse")
	proto.RegisterType((*GfSpListExpiredBucketsBySpRequest)(nil), "modular.metadata.types.GfSpListExpiredBucketsBySpRequest")
	proto.RegisterType((*GfSpListExpiredBucketsBySpResponse)(nil), "modular.metadata.types.GfSpListExpiredBucketsBySpResponse")
	proto.RegisterType((*GfSpGetObjectMetaRequest)(nil), "modular.metadata.types.GfSpGetObjectMetaRequest")
	proto.RegisterType((*GfSpGetObjectMetaResponse)(nil), "modular.metadata.types.GfSpGetObjectMetaResponse")
	proto.RegisterType((*GfSpGetPaymentByBucketNameRequest)(nil), "modular.metadata.types.GfSpGetPaymentByBucketNameRequest")
	proto.RegisterType((*GfSpGetPaymentByBucketNameResponse)(nil), "modular.metadata.types.GfSpGetPaymentByBucketNameResponse")
	proto.RegisterType((*GfSpGetPaymentByBucketIDRequest)(nil), "modular.metadata.types.GfSpGetPaymentByBucketIDRequest")
	proto.RegisterType((*GfSpGetPaymentByBucketIDResponse)(nil), "modular.metadata.types.GfSpGetPaymentByBucketIDResponse")
	proto.RegisterType((*GfSpGetBucketMetaRequest)(nil), "modular.metadata.types.GfSpGetBucketMetaRequest")
	proto.RegisterType((*GfSpGetBucketMetaResponse)(nil), "modular.metadata.types.GfSpGetBucketMetaResponse")
	proto.RegisterType((*GfSpGetEndpointBySpAddressRequest)(nil), "modular.metadata.types.GfSpGetEndpointBySpAddressRequest")
	proto.RegisterType((*GfSpGetEndpointBySpAddressResponse)(nil), "modular.metadata.types.GfSpGetEndpointBySpAddressResponse")
	proto.RegisterType((*GfSpGetBucketReadQuotaRequest)(nil), "modular.metadata.types.GfSpGetBucketReadQuotaRequest")
	proto.RegisterType((*GfSpGetBucketReadQuotaResponse)(nil), "modular.metadata.types.GfSpGetBucketReadQuotaResponse")
	proto.RegisterType((*GfSpListBucketReadRecordRequest)(nil), "modular.metadata.types.GfSpListBucketReadRecordRequest")
	proto.RegisterType((*ReadRecord)(nil), "modular.metadata.types.ReadRecord")
	proto.RegisterType((*GfSpListBucketReadRecordResponse)(nil), "modular.metadata.types.GfSpListBucketReadRecordResponse")
	proto.RegisterType((*GfSpQueryUploadProgressRequest)(nil), "modular.metadata.types.GfSpQueryUploadProgressRequest")
	proto.RegisterType((*GfSpQueryUploadProgressResponse)(nil), "modular.metadata.types.GfSpQueryUploadProgressResponse")
}

func init() {
	proto.RegisterFile("modular/metadata/types/metadata.proto", fileDescriptor_7cdcff708e247f22)
}

var fileDescriptor_7cdcff708e247f22 = []byte{
	// 1976 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x59, 0xcd, 0x8f, 0x1b, 0x49,
	0x15, 0x9f, 0x1e, 0xcf, 0x87, 0x5d, 0x33, 0x99, 0xcd, 0x16, 0x21, 0xf1, 0x7a, 0x88, 0xc7, 0xe9,
	0x64, 0x61, 0x24, 0x18, 0x3b, 0x3b, 0x68, 0x93, 0x6c, 0x10, 0x5a, 0x66, 0x76, 0xb3, 0xd9, 0xb0,
	0x24, 0x64, 0xdb, 0xc9, 0x4a, 0x80, 0xa0, 0x29, 0xbb, 0x9f, 0x3d, 0xcd, 0xb8, 0x3f, 0x52, 0x55,
	0x8e, 0xc6, 0x91, 0x16, 0x2e, 0x70, 0x40, 0x42, 0x02, 0x21, 0x40, 0x88, 0x23, 0x57, 0x8e, 0xfc,
	0x01, 0x5c, 0x57, 0xe2, 0xb2, 0x07, 0x0e, 0x88, 0x03, 0x8a, 0x92, 0x3f, 0x81, 0x7f, 0x00, 0xd5,
	0x47, 0xb7, 0xdb, 0x76, 0x7f, 0x78, 0xc6, 0xd9, 0xd3, 0x74, 0xbd, 0xfa, 0xd5, 0xab, 0xf7, 0x5d,
	0xef, 0x79, 0xd0, 0x9b, 0x5e, 0xe0, 0x0c, 0x07, 0x84, 0xb6, 0x3c, 0xe0, 0xc4, 0x21, 0x9c, 0xb4,
	0xf8, 0x28, 0x04, 0x16, 0x2f, 0x9b, 0x21, 0x0d, 0x78, 0x80, 0x2f, 0x6a, 0x58, 0x33, 0xa6, 0x4b,
	0x58, 0xed, 0x4a, 0x87, 0x30, 0xd0, 0x47, 0xfa, 0x3d, 0x16, 0x02, 0xa5, 0x01, 0x65, 0x2d, 0xf9,
	0x47, 0x1d, 0xad, 0x5d, 0xe8, 0x07, 0xfd, 0x40, 0x7e, 0xb6, 0xc4, 0x97, 0xa6, 0x7e, 0xb5, 0x4f,
	0x01, 0xfc, 0x9e, 0x0b, 0x03, 0xa7, 0x15, 0x92, 0x91, 0x07, 0x3e, 0x6f, 0x31, 0x4e, 0x81, 0x78,
	0x36, 0x85, 0x6e, 0x40, 0x1d, 0x8d, 0xab, 0x27, 0x70, 0x8c, 0x07, 0x94, 0xf4, 0xa1, 0xf5, 0x64,
	0x08, 0x74, 0x94, 0xb3, 0x2f, 0xc5, 0xd1, 0xfb, 0xd7, 0x18, 0xd0, 0xa7, 0x6e, 0x37, 0x92, 0x51,
	0x43, 0xec, 0x90, 0x06, 0x4f, 0x5d, 0x07, 0xb4, 0x8c, 0xe6, 0x3f, 0x97, 0xd1, 0xda, 0xe1, 0xb0,
	0x7b, 0x0c, 0x1c, 0xbf, 0x8b, 0x36, 0x3a, 0xf2, 0xcb, 0x76, 0xfd, 0x5e, 0x50, 0x35, 0x1a, 0xc6,
	0xee, 0xc6, 0x7e, 0xbd, 0x39, 0xbe, 0xa6, 0xa9, 0x79, 0x34, 0xd5, 0x81, 0x7b, 0x7e, 0x2f, 0xb0,
	0x50, 0x27, 0xfe, 0xc6, 0x55, 0xb4, 0x4e, 0xc1, 0x0b, 0x9e, 0x82, 0x53, 0x5d, 0x6e, 0x18, 0xbb,
	0x65, 0x2b, 0x5a, 0xe2, 0x6d, 0x54, 0x71, 0x60, 0x00, 0x1c, 0x6c, 0xc2, 0xab, 0xa5, 0x86, 0xb1,
	0x5b, 0xb2, 0xca, 0x8a, 0x70, 0xc0, 0xf1, 0x55, 0x74, 0x4e, 0x6f, 0x52, 0x20, 0x2c, 0xf0, 0xab,
	0x2b, 0x0d, 0x63, 0xb7, 0x62, 0x6d, 0x2a, 0xa2, 0x25, 0x69, 0xb8, 0x86, 0xca, 0x41, 0x08, 0x94,
	0xf0, 0x80, 0x56, 0x57, 0xe5, 0x7e, 0xbc, 0xc6, 0xd7, 0xd0, 0x56, 0x97, 0x02, 0xe1, 0x60, 0xf3,
	0x13, 0xfb, 0x88, 0xb0, 0xa3, 0xea, 0x9a, 0xe2, 0xa0, 0xa8, 0x8f, 0x4e, 0x3e, 0x24, 0xec, 0x48,
	0xa0, 0x86, 0xa1, 0x93, 0x44, 0xad, 0x2b, 0x94, 0xa2, 0x6a, 0xd4, 0x36, 0xaa, 0x68, 0x14, 0xe1,
	0xd5, 0xb2, 0x92, 0x54, 0x11, 0x0e, 0x38, 0xde, 0x41, 0x1b, 0x11, 0x0b, 0xd7, 0x83, 0x6a, 0x45,
	0x6e, 0x23, 0x7d, 0xde, 0xf5, 0xc0, 0xfc, 0xdf, 0x32, 0x5a, 0xfb, 0x7e, 0xe7, 0x67, 0xd0, 0x95,
	0xd6, 0x0c, 0xe4, 0x57, 0xa1, 0x35, 0xd5, 0x01, 0x65, 0xcd, 0x20, 0xfe, 0xc6, 0x6f, 0xa2, 0xad,
	0x41, 0xd0, 0x3d, 0x06, 0xc7, 0xee, 0x90, 0x01, 0xf1, 0xbb, 0x20, 0x8d, 0x5a, 0xb1, 0xce, 0x29,
	0xea, 0xa1, 0x22, 0x26, 0x8d, 0x5e, 0x9a, 0x31, 0xfa, 0x58, 0x95, 0x95, 0x29, 0x55, 0x26, 0x3c,
	0xb2, 0x5a, 0xe4, 0x91, 0xb5, 0x02, 0x8f, 0xac, 0x17, 0x7a, 0xa4, 0x3c, 0x97, 0x47, 0x2a, 0x29,
	0x1e, 0x69, 0xa0, 0x4d, 0x06, 0x64, 0x10, 0x63, 0x90, 0xc4, 0x20, 0x41, 0x53, 0x08, 0xf3, 0x36,
	0x7a, 0xe3, 0x6e, 0xaf, 0x1d, 0xde, 0x05, 0xfe, 0x98, 0x01, 0x55, 0xc1, 0xc9, 0x2c, 0x78, 0x32,
	0x04, 0xc6, 0xf1, 0x65, 0x84, 0x48, 0xb7, 0x1b, 0x0c, 0x7d, 0x6e, 0xbb, 0x8e, 0x74, 0x43, 0xc5,
	0xaa, 0x68, 0xca, 0x3d, 0xc7, 0xfc, 0x04, 0xd5, 0xd2, 0xce, 0xb2, 0x30, 0xf0, 0x19, 0xe0, 0x5b,
	0x68, 0x5d, 0xc5, 0x37, 0xab, 0x1a, 0x8d, 0x92, 0x74, 0x60, 0x7a, 0x39, 0xd0, 0x29, 0x61, 0x45,
	0x70, 0xf3, 0x57, 0xcb, 0xc8, 0x14, 0x8c, 0xbf, 0xe7, 0x32, 0xae, 0x1c, 0xcc, 0x0e, 0x47, 0x0a,
	0xf4, 0x80, 0x78, 0x10, 0x49, 0xb7, 0x13, 0xe7, 0x9c, 0x4f, 0x3c, 0xd0, 0xe2, 0xe9, 0x9c, 0x12,
	0xb8, 0x29, 0xf1, 0x97, 0xa7, 0xc4, 0xc7, 0x6f, 0xa0, 0xb2, 0x47, 0x4e, 0xec, 0x63, 0x18, 0x31,
	0xe9, 0xfe, 0x15, 0x6b, 0xdd, 0x23, 0x27, 0x1f, 0xc1, 0x88, 0x09, 0xd6, 0x8c, 0x13, 0xca, 0x6d,
	0xd2, 0xe3, 0x40, 0x75, 0x52, 0x21, 0x49, 0x3a, 0x10, 0x14, 0xbc, 0x87, 0x70, 0x37, 0xf0, 0xb9,
	0xeb, 0x0f, 0x09, 0x77, 0x03, 0xdf, 0xe6, 0xc1, 0x31, 0xf8, 0x3a, 0xb9, 0x5e, 0x4f, 0xee, 0x3c,
	0x12, 0x1b, 0xf8, 0x2b, 0x32, 0x62, 0x5c, 0xcf, 0x15, 0xdc, 0x54, 0x40, 0x8c, 0x09, 0xf8, 0x22,
	0x5a, 0x0b, 0x29, 0xf4, 0xdc, 0x13, 0x1d, 0x0b, 0x7a, 0x65, 0xfe, 0xa1, 0x84, 0xae, 0xe6, 0xda,
	0x61, 0x6c, 0x69, 0x15, 0xfb, 0x85, 0x96, 0x56, 0x5c, 0xac, 0x08, 0x2e, 0x22, 0xf9, 0x18, 0x46,
	0xb6, 0xb4, 0x88, 0x34, 0xd0, 0x8a, 0x55, 0x3e, 0x86, 0xd1, 0x7b, 0x62, 0x9d, 0x67, 0x9f, 0x2b,
	0x68, 0xd3, 0x65, 0x36, 0xa7, 0x43, 0xbf, 0x4b, 0x38, 0x38, 0xd2, 0x40, 0x65, 0x6b, 0xc3, 0x65,
	0x8f, 0x22, 0x12, 0xbe, 0x81, 0x2e, 0xf9, 0x70, 0xc2, 0xed, 0x4c, 0x33, 0x7d, 0x59, 0x6c, 0xbf,
	0x37, 0x63, 0x2a, 0x8c, 0x56, 0xa4, 0x3b, 0x95, 0x95, 0xe4, 0x77, 0x96, 0x81, 0x26, 0xcd, 0x5a,
	0x9e, 0x36, 0xeb, 0xd7, 0xd0, 0x6b, 0xdd, 0xc0, 0xf3, 0x02, 0xdf, 0x56, 0x70, 0x60, 0xd5, 0x4a,
	0xa3, 0xb4, 0x5b, 0xb1, 0xb6, 0x14, 0xf9, 0xa1, 0xa6, 0x66, 0x38, 0x13, 0x65, 0x38, 0xd3, 0x04,
	0xd4, 0xd0, 0x61, 0xaf, 0x7c, 0x71, 0xa6, 0xd8, 0x6c, 0x48, 0x0b, 0xf6, 0x86, 0x83, 0x81, 0x3d,
	0x70, 0x19, 0xd7, 0x45, 0x1f, 0xb9, 0xec, 0x83, 0xe1, 0x60, 0x20, 0x1c, 0x6e, 0xfe, 0x08, 0x5d,
	0xc9, 0xb9, 0x46, 0xbb, 0xfe, 0x06, 0x5a, 0x53, 0x4c, 0xe3, 0x22, 0x99, 0x9f, 0x63, 0x1a, 0x6d,
	0xda, 0xa8, 0x9e, 0xca, 0xfc, 0xde, 0xfb, 0x91, 0x06, 0xdb, 0xa8, 0x12, 0xbd, 0x68, 0x2a, 0xf5,
	0x4b, 0x56, 0x59, 0xbf, 0x57, 0xce, 0x1c, 0xd2, 0xff, 0x00, 0xed, 0x64, 0x5e, 0xb0, 0xa0, 0xec,
	0x7f, 0x33, 0x50, 0x2b, 0x4a, 0x8b, 0xf7, 0x65, 0x55, 0x75, 0xc6, 0xd9, 0x21, 0x0a, 0xfc, 0x83,
	0xa1, 0xd7, 0x01, 0x6a, 0x11, 0xbf, 0x1f, 0xfb, 0xe3, 0x1b, 0x08, 0xab, 0x84, 0xee, 0x08, 0x80,
	0xed, 0x4b, 0x84, 0x56, 0xeb, 0xbc, 0xdc, 0x49, 0x9c, 0xc4, 0xbb, 0xe8, 0x3c, 0xf8, 0xce, 0x24,
	0x76, 0x59, 0x62, 0xb7, 0xc0, 0x77, 0x92, 0xc8, 0x69, 0x43, 0x94, 0x66, 0x0c, 0xf1, 0x27, 0x03,
	0x5d, 0x9f, 0x5f, 0xda, 0x85, 0x33, 0x7a, 0x6e, 0xd1, 0xcd, 0x77, 0xe3, 0x10, 0x48, 0x54, 0x6f,
	0x99, 0xf9, 0x73, 0x96, 0xff, 0x9b, 0xb1, 0x8b, 0x67, 0x19, 0x68, 0x3d, 0x2e, 0xa0, 0x55, 0x55,
	0x5b, 0x94, 0xa5, 0xd5, 0xc2, 0xfc, 0xa5, 0xa1, 0x42, 0x5b, 0x98, 0xe4, 0xce, 0x49, 0xe8, 0x52,
	0x70, 0xf4, 0xe9, 0xc3, 0x51, 0x3b, 0x4c, 0x04, 0xa0, 0x7e, 0x07, 0x49, 0x74, 0xbe, 0xac, 0x08,
	0x07, 0xd2, 0x9f, 0x21, 0x75, 0x3d, 0x42, 0x47, 0x36, 0x0b, 0x6d, 0xe2, 0x38, 0x14, 0x18, 0xd3,
	0x25, 0xfe, 0xbc, 0xde, 0x69, 0x87, 0x07, 0x8a, 0x2e, 0xc4, 0x90, 0x45, 0x41, 0xb7, 0x4f, 0x6a,
	0x61, 0xfe, 0x64, 0xfc, 0xca, 0xa4, 0x49, 0xb1, 0xf0, 0x33, 0xf6, 0x73, 0x54, 0xd5, 0xf6, 0x51,
	0x4e, 0xba, 0x0f, 0x9c, 0x24, 0xea, 0x83, 0xee, 0x70, 0x92, 0xf5, 0x41, 0x91, 0x64, 0x7d, 0x98,
	0x2a, 0x20, 0xcb, 0x85, 0x05, 0x64, 0x36, 0xf2, 0xda, 0xf1, 0xd3, 0x9e, 0xbc, 0x7f, 0x9c, 0x7c,
	0xea, 0xb6, 0xa2, 0xe4, 0xd3, 0x01, 0xa6, 0xd1, 0x66, 0x2f, 0xae, 0x4a, 0x0f, 0x55, 0xff, 0xfd,
	0x05, 0x55, 0xbf, 0x63, 0xe5, 0x9c, 0xac, 0x7b, 0xb4, 0x16, 0x77, 0xd0, 0xb9, 0x89, 0xf6, 0x5f,
	0x2b, 0xd3, 0x48, 0xb6, 0x8a, 0x7a, 0x4e, 0x68, 0xb6, 0x25, 0xd0, 0x92, 0x38, 0x6b, 0x93, 0x25,
	0x56, 0xe6, 0x4f, 0xe3, 0x48, 0x9e, 0xba, 0xec, 0x95, 0x95, 0x43, 0x37, 0x7e, 0x33, 0x52, 0x6e,
	0x78, 0xb5, 0xca, 0xfc, 0x38, 0x0e, 0x3b, 0x75, 0xc3, 0x54, 0xd8, 0x2d, 0xea, 0x98, 0xbf, 0x18,
	0x71, 0x58, 0x25, 0xf9, 0x2f, 0x56, 0xd3, 0x67, 0x75, 0x5f, 0x3e, 0x93, 0xee, 0x87, 0x71, 0x74,
	0xde, 0xf1, 0x9d, 0x30, 0x70, 0x85, 0x9d, 0xe3, 0x32, 0x90, 0x28, 0x6b, 0x89, 0x9a, 0xa1, 0xcb,
	0x1a, 0x8b, 0x50, 0xe6, 0x77, 0xe2, 0xc8, 0x4b, 0xe5, 0xa1, 0x15, 0xad, 0xa1, 0x32, 0xe8, 0x6d,
	0xcd, 0x22, 0x5e, 0x9b, 0xbf, 0x40, 0x97, 0x27, 0x2c, 0x64, 0x01, 0x71, 0x3e, 0x1e, 0x06, 0x63,
	0x37, 0x2c, 0x3c, 0x2d, 0x5e, 0x46, 0x68, 0x04, 0x84, 0xda, 0x5e, 0xe0, 0xf3, 0xa3, 0xa8, 0xb3,
	0x15, 0x94, 0xfb, 0x82, 0x60, 0xfe, 0xcb, 0x98, 0x7a, 0xde, 0x13, 0x12, 0x68, 0xf9, 0xf7, 0x51,
	0x09, 0x28, 0x8d, 0x43, 0x4c, 0x0c, 0xe4, 0xda, 0x33, 0xe3, 0x81, 0xbc, 0x29, 0x78, 0xdc, 0x11,
	0x9f, 0x96, 0x00, 0x8b, 0xa2, 0xdb, 0x3d, 0x22, 0xb4, 0x0f, 0x8e, 0xfd, 0x44, 0x30, 0xb3, 0x99,
	0xfb, 0x0c, 0x74, 0xdb, 0x78, 0x5e, 0xef, 0xc8, 0x5b, 0xda, 0xee, 0x33, 0xc0, 0x5f, 0x47, 0x98,
	0x85, 0x76, 0x8f, 0x02, 0x24, 0xd1, 0xaa, 0x91, 0x7c, 0x8d, 0x85, 0x1f, 0x50, 0x80, 0x31, 0xf8,
	0x2a, 0x3a, 0xd7, 0x0d, 0x7c, 0x36, 0xf4, 0xc0, 0x51, 0xb8, 0x15, 0x89, 0xdb, 0x8c, 0x88, 0x02,
	0x64, 0x3e, 0x37, 0x54, 0x9e, 0x8a, 0x38, 0x1c, 0xeb, 0xa5, 0x03, 0xe1, 0x55, 0x99, 0x36, 0xee,
	0x14, 0xc4, 0x98, 0xca, 0x38, 0xf1, 0x42, 0x7b, 0xc8, 0xf4, 0x13, 0xaa, 0x3a, 0x85, 0x47, 0xd1,
	0xc6, 0xe3, 0xf8, 0xb9, 0x9d, 0xc0, 0x96, 0xe2, 0xe7, 0x36, 0x89, 0xbc, 0x86, 0xb6, 0x44, 0x37,
	0xad, 0xc2, 0x5b, 0xbc, 0xcc, 0x7a, 0xac, 0xdc, 0xf4, 0xc8, 0x89, 0x52, 0xe1, 0xc1, 0xd0, 0x33,
	0xff, 0x6e, 0x20, 0x34, 0x56, 0xaa, 0xf8, 0x99, 0xd8, 0x46, 0x95, 0x68, 0x52, 0x76, 0xa2, 0x06,
	0x5e, 0xcf, 0xc1, 0x8e, 0x68, 0x80, 0xa3, 0xf7, 0x3b, 0x8a, 0xf6, 0x92, 0xe4, 0xb0, 0xa5, 0xc9,
	0xd1, 0xfb, 0x78, 0x05, 0x6d, 0x4e, 0x68, 0xa0, 0x24, 0xdb, 0xe0, 0x09, 0xf1, 0xb7, 0x51, 0x85,
	0x02, 0xd1, 0xce, 0x59, 0x55, 0x17, 0x09, 0x82, 0x74, 0xcc, 0x7f, 0x0c, 0x55, 0xde, 0xd2, 0x1d,
	0xb3, 0x40, 0xc4, 0x7d, 0x84, 0x36, 0xe5, 0xad, 0xca, 0x6a, 0xc2, 0x0d, 0xe2, 0x05, 0x36, 0xb3,
	0x8a, 0xca, 0xf8, 0xd6, 0xc3, 0x95, 0xcf, 0xfe, 0xbb, 0x63, 0x58, 0x1b, 0x34, 0xa6, 0x30, 0xfc,
	0xb6, 0x9e, 0x48, 0x52, 0xdc, 0xab, 0x5c, 0x76, 0x41, 0x6c, 0xb7, 0xa7, 0x5c, 0x6c, 0x7e, 0x5b,
	0xe5, 0xd2, 0xc7, 0x43, 0xa0, 0xa3, 0xc7, 0xe1, 0x20, 0x20, 0xce, 0x43, 0x1a, 0xf4, 0x93, 0x05,
	0x65, 0xc2, 0x09, 0xc6, 0xa4, 0x13, 0x44, 0xb3, 0xb3, 0x93, 0x79, 0x7e, 0x01, 0xd3, 0xec, 0xa1,
	0x55, 0xc6, 0x09, 0x57, 0xf9, 0xb7, 0xb5, 0x7f, 0xa9, 0xa9, 0x7f, 0xb2, 0xd2, 0x07, 0xbf, 0x1b,
	0x74, 0xda, 0x62, 0xdb, 0x52, 0xa8, 0xfd, 0xbf, 0x62, 0xf4, 0x25, 0xc1, 0xe1, 0xbe, 0xb6, 0x58,
	0x5b, 0xa1, 0xf1, 0xa7, 0x08, 0xcf, 0x36, 0x71, 0xf8, 0xad, 0x2c, 0x0b, 0x67, 0xfe, 0x56, 0x50,
	0xdb, 0x3f, 0xcd, 0x11, 0xa5, 0xb7, 0xb9, 0x84, 0xff, 0x6c, 0xa0, 0xed, 0x9c, 0x11, 0x17, 0xdf,
	0xce, 0xe3, 0x9a, 0xff, 0xfb, 0x40, 0xed, 0x5b, 0x67, 0x3a, 0x1b, 0x8b, 0xf6, 0xfb, 0xe9, 0x87,
	0x6e, 0x42, 0xb0, 0x5b, 0x05, 0xea, 0x66, 0x8e, 0x86, 0xb5, 0x77, 0xce, 0x70, 0x32, 0x16, 0xea,
	0x37, 0x06, 0xba, 0x94, 0x31, 0x57, 0xe1, 0x1b, 0xa7, 0x62, 0x1c, 0xb7, 0x36, 0xb5, 0x9b, 0xa7,
	0x3e, 0x17, 0x8b, 0xf3, 0x0f, 0x03, 0xed, 0xce, 0x3b, 0xdc, 0xe0, 0xbb, 0x45, 0xfe, 0x98, 0x73,
	0x98, 0xab, 0x7d, 0xb8, 0x38, 0xa3, 0x34, 0x83, 0x4e, 0x4f, 0x31, 0x85, 0x06, 0xcd, 0x98, 0x9b,
	0x0a, 0x0d, 0x9a, 0x35, 0x2e, 0x99, 0x4b, 0xf8, 0x8f, 0x86, 0xfa, 0x4d, 0x2d, 0x7d, 0x28, 0xc1,
	0xef, 0x14, 0x69, 0x9e, 0x39, 0x4e, 0xd5, 0x6e, 0x9f, 0xe5, 0x68, 0x2c, 0xd7, 0x33, 0xf4, 0xfa,
	0xcc, 0x2c, 0x81, 0xaf, 0x17, 0xe8, 0x39, 0x33, 0xf6, 0xd4, 0xde, 0x3a, 0xc5, 0x89, 0x19, 0x9b,
	0xa4, 0xcf, 0x02, 0xb8, 0x28, 0x9f, 0xb2, 0xe7, 0x94, 0x7c, 0x9b, 0xe4, 0x8f, 0x1e, 0xe6, 0x12,
	0xfe, 0xad, 0x11, 0x77, 0xda, 0x33, 0x4d, 0x3d, 0xbe, 0x79, 0x3a, 0xd6, 0xe3, 0x6c, 0xbc, 0x75,
	0xfa, 0x83, 0xb1, 0x44, 0x9f, 0xa2, 0x0b, 0x02, 0xf5, 0x09, 0x50, 0xb7, 0x37, 0x7a, 0x08, 0xd4,
	0x73, 0x19, 0x73, 0x03, 0x1f, 0x5f, 0x4f, 0xeb, 0x7f, 0xe4, 0x83, 0x34, 0x0d, 0x1d, 0x3b, 0x6a,
	0xfe, 0x13, 0x29, 0x41, 0x32, 0x9e, 0x0c, 0x0a, 0x83, 0x64, 0x66, 0x48, 0x29, 0x0c, 0x92, 0xd9,
	0xb1, 0x63, 0x32, 0x48, 0x52, 0xda, 0xf6, 0xc2, 0x20, 0xc9, 0x1e, 0x17, 0x0a, 0x83, 0x24, 0x67,
	0x4a, 0x30, 0x97, 0xf0, 0xaf, 0x0d, 0x74, 0x31, 0xbd, 0x15, 0xc7, 0x6f, 0xcf, 0xa5, 0xe7, 0xf4,
	0xf0, 0x50, 0xbb, 0x71, 0xda, 0x63, 0x33, 0x01, 0x9b, 0xd6, 0xa6, 0xe5, 0x07, 0x6c, 0x4e, 0xc7,
	0x9d, 0x1f, 0xb0, 0x79, 0x1d, 0x61, 0xa2, 0xfa, 0xa6, 0x34, 0x47, 0xf9, 0xd5, 0x37, 0xbb, 0x1b,
	0xcb, 0xaf, 0xbe, 0x39, 0x5d, 0x98, 0xb9, 0x74, 0x48, 0x3e, 0x7b, 0x51, 0x37, 0x3e, 0x7f, 0x51,
	0x37, 0x9e, 0xbf, 0xa8, 0x1b, 0xbf, 0x7b, 0x59, 0x5f, 0xfa, 0xfc, 0x65, 0x7d, 0xe9, 0xdf, 0x2f,
	0xeb, 0x4b, 0x3f, 0xbc, 0xdb, 0x77, 0xf9, 0xd1, 0xb0, 0xd3, 0xec, 0x06, 0x5e, 0xab, 0xe3, 0x77,
	0xf6, 0xba, 0x47, 0xc4, 0xf5, 0x5b, 0xe3, 0x1c, 0xd9, 0xd3, 0x39, 0xb2, 0x17, 0xfd, 0x8b, 0xb0,
	0x95, 0xfe, 0x1f, 0xd2, 0xce, 0x9a, 0xfc, 0xd7, 0xe1, 0x37, 0xff, 0x1f, 0x00, 0x00, 0xff, 0xff,
	0x17, 0x18, 0x64, 0x78, 0x42, 0x1d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GfSpMetadataServiceClient is the client API for GfSpMetadataService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GfSpMetadataServiceClient interface {
	GfSpGetUserBuckets(ctx context.Context, in *GfSpGetUserBucketsRequest, opts ...grpc.CallOption) (*GfSpGetUserBucketsResponse, error)
	GfSpListObjectsByBucketName(ctx context.Context, in *GfSpListObjectsByBucketNameRequest, opts ...grpc.CallOption) (*GfSpListObjectsByBucketNameResponse, error)
	GfSpGetBucketByBucketName(ctx context.Context, in *GfSpGetBucketByBucketNameRequest, opts ...grpc.CallOption) (*GfSpGetBucketByBucketNameResponse, error)
	GfSpGetBucketByBucketID(ctx context.Context, in *GfSpGetBucketByBucketIDRequest, opts ...grpc.CallOption) (*GfSpGetBucketByBucketIDResponse, error)
	GfSpListDeletedObjectsByBlockNumberRange(ctx context.Context, in *GfSpListDeletedObjectsByBlockNumberRangeRequest, opts ...grpc.CallOption) (*GfSpListDeletedObjectsByBlockNumberRangeResponse, error)
	GfSpGetUserBucketsCount(ctx context.Context, in *GfSpGetUserBucketsCountRequest, opts ...grpc.CallOption) (*GfSpGetUserBucketsCountResponse, error)
	GfSpListExpiredBucketsBySp(ctx context.Context, in *GfSpListExpiredBucketsBySpRequest, opts ...grpc.CallOption) (*GfSpListExpiredBucketsBySpResponse, error)
	GfSpGetObjectMeta(ctx context.Context, in *GfSpGetObjectMetaRequest, opts ...grpc.CallOption) (*GfSpGetObjectMetaResponse, error)
	GfSpGetPaymentByBucketName(ctx context.Context, in *GfSpGetPaymentByBucketNameRequest, opts ...grpc.CallOption) (*GfSpGetPaymentByBucketNameResponse, error)
	GfSpGetPaymentByBucketID(ctx context.Context, in *GfSpGetPaymentByBucketIDRequest, opts ...grpc.CallOption) (*GfSpGetPaymentByBucketIDResponse, error)
	GfSpVerifyPermission(ctx context.Context, in *types.QueryVerifyPermissionRequest, opts ...grpc.CallOption) (*types.QueryVerifyPermissionResponse, error)
	GfSpGetBucketMeta(ctx context.Context, in *GfSpGetBucketMetaRequest, opts ...grpc.CallOption) (*GfSpGetBucketMetaResponse, error)
	GfSpGetEndpointBySpAddress(ctx context.Context, in *GfSpGetEndpointBySpAddressRequest, opts ...grpc.CallOption) (*GfSpGetEndpointBySpAddressResponse, error)
	GfSpGetBucketReadQuota(ctx context.Context, in *GfSpGetBucketReadQuotaRequest, opts ...grpc.CallOption) (*GfSpGetBucketReadQuotaResponse, error)
	GfSpListBucketReadRecord(ctx context.Context, in *GfSpListBucketReadRecordRequest, opts ...grpc.CallOption) (*GfSpListBucketReadRecordResponse, error)
	GfSpQueryUploadProgress(ctx context.Context, in *GfSpQueryUploadProgressRequest, opts ...grpc.CallOption) (*GfSpQueryUploadProgressResponse, error)
}

type gfSpMetadataServiceClient struct {
	cc grpc1.ClientConn
}

func NewGfSpMetadataServiceClient(cc grpc1.ClientConn) GfSpMetadataServiceClient {
	return &gfSpMetadataServiceClient{cc}
}

func (c *gfSpMetadataServiceClient) GfSpGetUserBuckets(ctx context.Context, in *GfSpGetUserBucketsRequest, opts ...grpc.CallOption) (*GfSpGetUserBucketsResponse, error) {
	out := new(GfSpGetUserBucketsResponse)
	err := c.cc.Invoke(ctx, "/modular.metadata.types.GfSpMetadataService/GfSpGetUserBuckets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gfSpMetadataServiceClient) GfSpListObjectsByBucketName(ctx context.Context, in *GfSpListObjectsByBucketNameRequest, opts ...grpc.CallOption) (*GfSpListObjectsByBucketNameResponse, error) {
	out := new(GfSpListObjectsByBucketNameResponse)
	err := c.cc.Invoke(ctx, "/modular.metadata.types.GfSpMetadataService/GfSpListObjectsByBucketName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gfSpMetadataServiceClient) GfSpGetBucketByBucketName(ctx context.Context, in *GfSpGetBucketByBucketNameRequest, opts ...grpc.CallOption) (*GfSpGetBucketByBucketNameResponse, error) {
	out := new(GfSpGetBucketByBucketNameResponse)
	err := c.cc.Invoke(ctx, "/modular.metadata.types.GfSpMetadataService/GfSpGetBucketByBucketName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gfSpMetadataServiceClient) GfSpGetBucketByBucketID(ctx context.Context, in *GfSpGetBucketByBucketIDRequest, opts ...grpc.CallOption) (*GfSpGetBucketByBucketIDResponse, error) {
	out := new(GfSpGetBucketByBucketIDResponse)
	err := c.cc.Invoke(ctx, "/modular.metadata.types.GfSpMetadataService/GfSpGetBucketByBucketID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gfSpMetadataServiceClient) GfSpListDeletedObjectsByBlockNumberRange(ctx context.Context, in *GfSpListDeletedObjectsByBlockNumberRangeRequest, opts ...grpc.CallOption) (*GfSpListDeletedObjectsByBlockNumberRangeResponse, error) {
	out := new(GfSpListDeletedObjectsByBlockNumberRangeResponse)
	err := c.cc.Invoke(ctx, "/modular.metadata.types.GfSpMetadataService/GfSpListDeletedObjectsByBlockNumberRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gfSpMetadataServiceClient) GfSpGetUserBucketsCount(ctx context.Context, in *GfSpGetUserBucketsCountRequest, opts ...grpc.CallOption) (*GfSpGetUserBucketsCountResponse, error) {
	out := new(GfSpGetUserBucketsCountResponse)
	err := c.cc.Invoke(ctx, "/modular.metadata.types.GfSpMetadataService/GfSpGetUserBucketsCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gfSpMetadataServiceClient) GfSpListExpiredBucketsBySp(ctx context.Context, in *GfSpListExpiredBucketsBySpRequest, opts ...grpc.CallOption) (*GfSpListExpiredBucketsBySpResponse, error) {
	out := new(GfSpListExpiredBucketsBySpResponse)
	err := c.cc.Invoke(ctx, "/modular.metadata.types.GfSpMetadataService/GfSpListExpiredBucketsBySp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gfSpMetadataServiceClient) GfSpGetObjectMeta(ctx context.Context, in *GfSpGetObjectMetaRequest, opts ...grpc.CallOption) (*GfSpGetObjectMetaResponse, error) {
	out := new(GfSpGetObjectMetaResponse)
	err := c.cc.Invoke(ctx, "/modular.metadata.types.GfSpMetadataService/GfSpGetObjectMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gfSpMetadataServiceClient) GfSpGetPaymentByBucketName(ctx context.Context, in *GfSpGetPaymentByBucketNameRequest, opts ...grpc.CallOption) (*GfSpGetPaymentByBucketNameResponse, error) {
	out := new(GfSpGetPaymentByBucketNameResponse)
	err := c.cc.Invoke(ctx, "/modular.metadata.types.GfSpMetadataService/GfSpGetPaymentByBucketName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gfSpMetadataServiceClient) GfSpGetPaymentByBucketID(ctx context.Context, in *GfSpGetPaymentByBucketIDRequest, opts ...grpc.CallOption) (*GfSpGetPaymentByBucketIDResponse, error) {
	out := new(GfSpGetPaymentByBucketIDResponse)
	err := c.cc.Invoke(ctx, "/modular.metadata.types.GfSpMetadataService/GfSpGetPaymentByBucketID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gfSpMetadataServiceClient) GfSpVerifyPermission(ctx context.Context, in *types.QueryVerifyPermissionRequest, opts ...grpc.CallOption) (*types.QueryVerifyPermissionResponse, error) {
	out := new(types.QueryVerifyPermissionResponse)
	err := c.cc.Invoke(ctx, "/modular.metadata.types.GfSpMetadataService/GfSpVerifyPermission", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gfSpMetadataServiceClient) GfSpGetBucketMeta(ctx context.Context, in *GfSpGetBucketMetaRequest, opts ...grpc.CallOption) (*GfSpGetBucketMetaResponse, error) {
	out := new(GfSpGetBucketMetaResponse)
	err := c.cc.Invoke(ctx, "/modular.metadata.types.GfSpMetadataService/GfSpGetBucketMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gfSpMetadataServiceClient) GfSpGetEndpointBySpAddress(ctx context.Context, in *GfSpGetEndpointBySpAddressRequest, opts ...grpc.CallOption) (*GfSpGetEndpointBySpAddressResponse, error) {
	out := new(GfSpGetEndpointBySpAddressResponse)
	err := c.cc.Invoke(ctx, "/modular.metadata.types.GfSpMetadataService/GfSpGetEndpointBySpAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gfSpMetadataServiceClient) GfSpGetBucketReadQuota(ctx context.Context, in *GfSpGetBucketReadQuotaRequest, opts ...grpc.CallOption) (*GfSpGetBucketReadQuotaResponse, error) {
	out := new(GfSpGetBucketReadQuotaResponse)
	err := c.cc.Invoke(ctx, "/modular.metadata.types.GfSpMetadataService/GfSpGetBucketReadQuota", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gfSpMetadataServiceClient) GfSpListBucketReadRecord(ctx context.Context, in *GfSpListBucketReadRecordRequest, opts ...grpc.CallOption) (*GfSpListBucketReadRecordResponse, error) {
	out := new(GfSpListBucketReadRecordResponse)
	err := c.cc.Invoke(ctx, "/modular.metadata.types.GfSpMetadataService/GfSpListBucketReadRecord", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gfSpMetadataServiceClient) GfSpQueryUploadProgress(ctx context.Context, in *GfSpQueryUploadProgressRequest, opts ...grpc.CallOption) (*GfSpQueryUploadProgressResponse, error) {
	out := new(GfSpQueryUploadProgressResponse)
	err := c.cc.Invoke(ctx, "/modular.metadata.types.GfSpMetadataService/GfSpQueryUploadProgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GfSpMetadataServiceServer is the server API for GfSpMetadataService service.
type GfSpMetadataServiceServer interface {
	GfSpGetUserBuckets(context.Context, *GfSpGetUserBucketsRequest) (*GfSpGetUserBucketsResponse, error)
	GfSpListObjectsByBucketName(context.Context, *GfSpListObjectsByBucketNameRequest) (*GfSpListObjectsByBucketNameResponse, error)
	GfSpGetBucketByBucketName(context.Context, *GfSpGetBucketByBucketNameRequest) (*GfSpGetBucketByBucketNameResponse, error)
	GfSpGetBucketByBucketID(context.Context, *GfSpGetBucketByBucketIDRequest) (*GfSpGetBucketByBucketIDResponse, error)
	GfSpListDeletedObjectsByBlockNumberRange(context.Context, *GfSpListDeletedObjectsByBlockNumberRangeRequest) (*GfSpListDeletedObjectsByBlockNumberRangeResponse, error)
	GfSpGetUserBucketsCount(context.Context, *GfSpGetUserBucketsCountRequest) (*GfSpGetUserBucketsCountResponse, error)
	GfSpListExpiredBucketsBySp(context.Context, *GfSpListExpiredBucketsBySpRequest) (*GfSpListExpiredBucketsBySpResponse, error)
	GfSpGetObjectMeta(context.Context, *GfSpGetObjectMetaRequest) (*GfSpGetObjectMetaResponse, error)
	GfSpGetPaymentByBucketName(context.Context, *GfSpGetPaymentByBucketNameRequest) (*GfSpGetPaymentByBucketNameResponse, error)
	GfSpGetPaymentByBucketID(context.Context, *GfSpGetPaymentByBucketIDRequest) (*GfSpGetPaymentByBucketIDResponse, error)
	GfSpVerifyPermission(context.Context, *types.QueryVerifyPermissionRequest) (*types.QueryVerifyPermissionResponse, error)
	GfSpGetBucketMeta(context.Context, *GfSpGetBucketMetaRequest) (*GfSpGetBucketMetaResponse, error)
	GfSpGetEndpointBySpAddress(context.Context, *GfSpGetEndpointBySpAddressRequest) (*GfSpGetEndpointBySpAddressResponse, error)
	GfSpGetBucketReadQuota(context.Context, *GfSpGetBucketReadQuotaRequest) (*GfSpGetBucketReadQuotaResponse, error)
	GfSpListBucketReadRecord(context.Context, *GfSpListBucketReadRecordRequest) (*GfSpListBucketReadRecordResponse, error)
	GfSpQueryUploadProgress(context.Context, *GfSpQueryUploadProgressRequest) (*GfSpQueryUploadProgressResponse, error)
}

// UnimplementedGfSpMetadataServiceServer can be embedded to have forward compatible implementations.
type UnimplementedGfSpMetadataServiceServer struct {
}

func (*UnimplementedGfSpMetadataServiceServer) GfSpGetUserBuckets(ctx context.Context, req *GfSpGetUserBucketsRequest) (*GfSpGetUserBucketsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GfSpGetUserBuckets not implemented")
}
func (*UnimplementedGfSpMetadataServiceServer) GfSpListObjectsByBucketName(ctx context.Context, req *GfSpListObjectsByBucketNameRequest) (*GfSpListObjectsByBucketNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GfSpListObjectsByBucketName not implemented")
}
func (*UnimplementedGfSpMetadataServiceServer) GfSpGetBucketByBucketName(ctx context.Context, req *GfSpGetBucketByBucketNameRequest) (*GfSpGetBucketByBucketNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GfSpGetBucketByBucketName not implemented")
}
func (*UnimplementedGfSpMetadataServiceServer) GfSpGetBucketByBucketID(ctx context.Context, req *GfSpGetBucketByBucketIDRequest) (*GfSpGetBucketByBucketIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GfSpGetBucketByBucketID not implemented")
}
func (*UnimplementedGfSpMetadataServiceServer) GfSpListDeletedObjectsByBlockNumberRange(ctx context.Context, req *GfSpListDeletedObjectsByBlockNumberRangeRequest) (*GfSpListDeletedObjectsByBlockNumberRangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GfSpListDeletedObjectsByBlockNumberRange not implemented")
}
func (*UnimplementedGfSpMetadataServiceServer) GfSpGetUserBucketsCount(ctx context.Context, req *GfSpGetUserBucketsCountRequest) (*GfSpGetUserBucketsCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GfSpGetUserBucketsCount not implemented")
}
func (*UnimplementedGfSpMetadataServiceServer) GfSpListExpiredBucketsBySp(ctx context.Context, req *GfSpListExpiredBucketsBySpRequest) (*GfSpListExpiredBucketsBySpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GfSpListExpiredBucketsBySp not implemented")
}
func (*UnimplementedGfSpMetadataServiceServer) GfSpGetObjectMeta(ctx context.Context, req *GfSpGetObjectMetaRequest) (*GfSpGetObjectMetaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GfSpGetObjectMeta not implemented")
}
func (*UnimplementedGfSpMetadataServiceServer) GfSpGetPaymentByBucketName(ctx context.Context, req *GfSpGetPaymentByBucketNameRequest) (*GfSpGetPaymentByBucketNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GfSpGetPaymentByBucketName not implemented")
}
func (*UnimplementedGfSpMetadataServiceServer) GfSpGetPaymentByBucketID(ctx context.Context, req *GfSpGetPaymentByBucketIDRequest) (*GfSpGetPaymentByBucketIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GfSpGetPaymentByBucketID not implemented")
}
func (*UnimplementedGfSpMetadataServiceServer) GfSpVerifyPermission(ctx context.Context, req *types.QueryVerifyPermissionRequest) (*types.QueryVerifyPermissionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GfSpVerifyPermission not implemented")
}
func (*UnimplementedGfSpMetadataServiceServer) GfSpGetBucketMeta(ctx context.Context, req *GfSpGetBucketMetaRequest) (*GfSpGetBucketMetaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GfSpGetBucketMeta not implemented")
}
func (*UnimplementedGfSpMetadataServiceServer) GfSpGetEndpointBySpAddress(ctx context.Context, req *GfSpGetEndpointBySpAddressRequest) (*GfSpGetEndpointBySpAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GfSpGetEndpointBySpAddress not implemented")
}
func (*UnimplementedGfSpMetadataServiceServer) GfSpGetBucketReadQuota(ctx context.Context, req *GfSpGetBucketReadQuotaRequest) (*GfSpGetBucketReadQuotaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GfSpGetBucketReadQuota not implemented")
}
func (*UnimplementedGfSpMetadataServiceServer) GfSpListBucketReadRecord(ctx context.Context, req *GfSpListBucketReadRecordRequest) (*GfSpListBucketReadRecordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GfSpListBucketReadRecord not implemented")
}
func (*UnimplementedGfSpMetadataServiceServer) GfSpQueryUploadProgress(ctx context.Context, req *GfSpQueryUploadProgressRequest) (*GfSpQueryUploadProgressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GfSpQueryUploadProgress not implemented")
}

func RegisterGfSpMetadataServiceServer(s grpc1.Server, srv GfSpMetadataServiceServer) {
	s.RegisterService(&_GfSpMetadataService_serviceDesc, srv)
}

func _GfSpMetadataService_GfSpGetUserBuckets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GfSpGetUserBucketsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpMetadataServiceServer).GfSpGetUserBuckets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modular.metadata.types.GfSpMetadataService/GfSpGetUserBuckets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpMetadataServiceServer).GfSpGetUserBuckets(ctx, req.(*GfSpGetUserBucketsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GfSpMetadataService_GfSpListObjectsByBucketName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GfSpListObjectsByBucketNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpMetadataServiceServer).GfSpListObjectsByBucketName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modular.metadata.types.GfSpMetadataService/GfSpListObjectsByBucketName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpMetadataServiceServer).GfSpListObjectsByBucketName(ctx, req.(*GfSpListObjectsByBucketNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GfSpMetadataService_GfSpGetBucketByBucketName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GfSpGetBucketByBucketNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpMetadataServiceServer).GfSpGetBucketByBucketName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modular.metadata.types.GfSpMetadataService/GfSpGetBucketByBucketName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpMetadataServiceServer).GfSpGetBucketByBucketName(ctx, req.(*GfSpGetBucketByBucketNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GfSpMetadataService_GfSpGetBucketByBucketID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GfSpGetBucketByBucketIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpMetadataServiceServer).GfSpGetBucketByBucketID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modular.metadata.types.GfSpMetadataService/GfSpGetBucketByBucketID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpMetadataServiceServer).GfSpGetBucketByBucketID(ctx, req.(*GfSpGetBucketByBucketIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GfSpMetadataService_GfSpListDeletedObjectsByBlockNumberRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GfSpListDeletedObjectsByBlockNumberRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpMetadataServiceServer).GfSpListDeletedObjectsByBlockNumberRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modular.metadata.types.GfSpMetadataService/GfSpListDeletedObjectsByBlockNumberRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpMetadataServiceServer).GfSpListDeletedObjectsByBlockNumberRange(ctx, req.(*GfSpListDeletedObjectsByBlockNumberRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GfSpMetadataService_GfSpGetUserBucketsCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GfSpGetUserBucketsCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpMetadataServiceServer).GfSpGetUserBucketsCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modular.metadata.types.GfSpMetadataService/GfSpGetUserBucketsCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpMetadataServiceServer).GfSpGetUserBucketsCount(ctx, req.(*GfSpGetUserBucketsCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GfSpMetadataService_GfSpListExpiredBucketsBySp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GfSpListExpiredBucketsBySpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpMetadataServiceServer).GfSpListExpiredBucketsBySp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modular.metadata.types.GfSpMetadataService/GfSpListExpiredBucketsBySp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpMetadataServiceServer).GfSpListExpiredBucketsBySp(ctx, req.(*GfSpListExpiredBucketsBySpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GfSpMetadataService_GfSpGetObjectMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GfSpGetObjectMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpMetadataServiceServer).GfSpGetObjectMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modular.metadata.types.GfSpMetadataService/GfSpGetObjectMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpMetadataServiceServer).GfSpGetObjectMeta(ctx, req.(*GfSpGetObjectMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GfSpMetadataService_GfSpGetPaymentByBucketName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GfSpGetPaymentByBucketNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpMetadataServiceServer).GfSpGetPaymentByBucketName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modular.metadata.types.GfSpMetadataService/GfSpGetPaymentByBucketName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpMetadataServiceServer).GfSpGetPaymentByBucketName(ctx, req.(*GfSpGetPaymentByBucketNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GfSpMetadataService_GfSpGetPaymentByBucketID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GfSpGetPaymentByBucketIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpMetadataServiceServer).GfSpGetPaymentByBucketID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modular.metadata.types.GfSpMetadataService/GfSpGetPaymentByBucketID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpMetadataServiceServer).GfSpGetPaymentByBucketID(ctx, req.(*GfSpGetPaymentByBucketIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GfSpMetadataService_GfSpVerifyPermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.QueryVerifyPermissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpMetadataServiceServer).GfSpVerifyPermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modular.metadata.types.GfSpMetadataService/GfSpVerifyPermission",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpMetadataServiceServer).GfSpVerifyPermission(ctx, req.(*types.QueryVerifyPermissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GfSpMetadataService_GfSpGetBucketMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GfSpGetBucketMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpMetadataServiceServer).GfSpGetBucketMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modular.metadata.types.GfSpMetadataService/GfSpGetBucketMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpMetadataServiceServer).GfSpGetBucketMeta(ctx, req.(*GfSpGetBucketMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GfSpMetadataService_GfSpGetEndpointBySpAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GfSpGetEndpointBySpAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpMetadataServiceServer).GfSpGetEndpointBySpAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modular.metadata.types.GfSpMetadataService/GfSpGetEndpointBySpAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpMetadataServiceServer).GfSpGetEndpointBySpAddress(ctx, req.(*GfSpGetEndpointBySpAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GfSpMetadataService_GfSpGetBucketReadQuota_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GfSpGetBucketReadQuotaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpMetadataServiceServer).GfSpGetBucketReadQuota(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modular.metadata.types.GfSpMetadataService/GfSpGetBucketReadQuota",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpMetadataServiceServer).GfSpGetBucketReadQuota(ctx, req.(*GfSpGetBucketReadQuotaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GfSpMetadataService_GfSpListBucketReadRecord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GfSpListBucketReadRecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpMetadataServiceServer).GfSpListBucketReadRecord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modular.metadata.types.GfSpMetadataService/GfSpListBucketReadRecord",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpMetadataServiceServer).GfSpListBucketReadRecord(ctx, req.(*GfSpListBucketReadRecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GfSpMetadataService_GfSpQueryUploadProgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GfSpQueryUploadProgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GfSpMetadataServiceServer).GfSpQueryUploadProgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/modular.metadata.types.GfSpMetadataService/GfSpQueryUploadProgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GfSpMetadataServiceServer).GfSpQueryUploadProgress(ctx, req.(*GfSpQueryUploadProgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _GfSpMetadataService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "modular.metadata.types.GfSpMetadataService",
	HandlerType: (*GfSpMetadataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GfSpGetUserBuckets",
			Handler:    _GfSpMetadataService_GfSpGetUserBuckets_Handler,
		},
		{
			MethodName: "GfSpListObjectsByBucketName",
			Handler:    _GfSpMetadataService_GfSpListObjectsByBucketName_Handler,
		},
		{
			MethodName: "GfSpGetBucketByBucketName",
			Handler:    _GfSpMetadataService_GfSpGetBucketByBucketName_Handler,
		},
		{
			MethodName: "GfSpGetBucketByBucketID",
			Handler:    _GfSpMetadataService_GfSpGetBucketByBucketID_Handler,
		},
		{
			MethodName: "GfSpListDeletedObjectsByBlockNumberRange",
			Handler:    _GfSpMetadataService_GfSpListDeletedObjectsByBlockNumberRange_Handler,
		},
		{
			MethodName: "GfSpGetUserBucketsCount",
			Handler:    _GfSpMetadataService_GfSpGetUserBucketsCount_Handler,
		},
		{
			MethodName: "GfSpListExpiredBucketsBySp",
			Handler:    _GfSpMetadataService_GfSpListExpiredBucketsBySp_Handler,
		},
		{
			MethodName: "GfSpGetObjectMeta",
			Handler:    _GfSpMetadataService_GfSpGetObjectMeta_Handler,
		},
		{
			MethodName: "GfSpGetPaymentByBucketName",
			Handler:    _GfSpMetadataService_GfSpGetPaymentByBucketName_Handler,
		},
		{
			MethodName: "GfSpGetPaymentByBucketID",
			Handler:    _GfSpMetadataService_GfSpGetPaymentByBucketID_Handler,
		},
		{
			MethodName: "GfSpVerifyPermission",
			Handler:    _GfSpMetadataService_GfSpVerifyPermission_Handler,
		},
		{
			MethodName: "GfSpGetBucketMeta",
			Handler:    _GfSpMetadataService_GfSpGetBucketMeta_Handler,
		},
		{
			MethodName: "GfSpGetEndpointBySpAddress",
			Handler:    _GfSpMetadataService_GfSpGetEndpointBySpAddress_Handler,
		},
		{
			MethodName: "GfSpGetBucketReadQuota",
			Handler:    _GfSpMetadataService_GfSpGetBucketReadQuota_Handler,
		},
		{
			MethodName: "GfSpListBucketReadRecord",
			Handler:    _GfSpMetadataService_GfSpListBucketReadRecord_Handler,
		},
		{
			MethodName: "GfSpQueryUploadProgress",
			Handler:    _GfSpMetadataService_GfSpQueryUploadProgress_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "modular/metadata/types/metadata.proto",
}

func (m *Bucket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bucket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Bucket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateTime != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.UpdateTime))
		i--
		dAtA[i] = 0x48
	}
	if m.UpdateAt != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x40
	}
	if len(m.UpdateTxHash) > 0 {
		i -= len(m.UpdateTxHash)
		copy(dAtA[i:], m.UpdateTxHash)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.UpdateTxHash)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CreateTxHash) > 0 {
		i -= len(m.CreateTxHash)
		copy(dAtA[i:], m.CreateTxHash)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.CreateTxHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DeleteReason) > 0 {
		i -= len(m.DeleteReason)
		copy(dAtA[i:], m.DeleteReason)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.DeleteReason)))
		i--
		dAtA[i] = 0x22
	}
	if m.DeleteAt != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.DeleteAt))
		i--
		dAtA[i] = 0x18
	}
	if m.Removed {
		i--
		if m.Removed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.BucketInfo != nil {
		{
			size, err := m.BucketInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Object) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Object) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SealTxHash) > 0 {
		i -= len(m.SealTxHash)
		copy(dAtA[i:], m.SealTxHash)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.SealTxHash)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.UpdateTxHash) > 0 {
		i -= len(m.UpdateTxHash)
		copy(dAtA[i:], m.UpdateTxHash)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.UpdateTxHash)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.CreateTxHash) > 0 {
		i -= len(m.CreateTxHash)
		copy(dAtA[i:], m.CreateTxHash)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.CreateTxHash)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DeleteReason) > 0 {
		i -= len(m.DeleteReason)
		copy(dAtA[i:], m.DeleteReason)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.DeleteReason)))
		i--
		dAtA[i] = 0x32
	}
	if m.DeleteAt != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.DeleteAt))
		i--
		dAtA[i] = 0x28
	}
	if m.UpdateAt != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x20
	}
	if m.Removed {
		i--
		if m.Removed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.LockedBalance) > 0 {
		i -= len(m.LockedBalance)
		copy(dAtA[i:], m.LockedBalance)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.LockedBalance)))
		i--
		dAtA[i] = 0x12
	}
	if m.ObjectInfo != nil {
		{
			size, err := m.ObjectInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetUserBucketsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetUserBucketsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetUserBucketsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AccountId) > 0 {
		i -= len(m.AccountId)
		copy(dAtA[i:], m.AccountId)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.AccountId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetUserBucketsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetUserBucketsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetUserBucketsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Buckets) > 0 {
		for iNdEx := len(m.Buckets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Buckets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GfSpListObjectsByBucketNameRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpListObjectsByBucketNameRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpListObjectsByBucketNameRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Delimiter) > 0 {
		i -= len(m.Delimiter)
		copy(dAtA[i:], m.Delimiter)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Delimiter)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ContinuationToken) > 0 {
		i -= len(m.ContinuationToken)
		copy(dAtA[i:], m.ContinuationToken)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.ContinuationToken)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StartAfter) > 0 {
		i -= len(m.StartAfter)
		copy(dAtA[i:], m.StartAfter)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.StartAfter)))
		i--
		dAtA[i] = 0x22
	}
	if m.MaxKeys != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.MaxKeys))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AccountId) > 0 {
		i -= len(m.AccountId)
		copy(dAtA[i:], m.AccountId)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.AccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BucketName) > 0 {
		i -= len(m.BucketName)
		copy(dAtA[i:], m.BucketName)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.BucketName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpListObjectsByBucketNameResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpListObjectsByBucketNameResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpListObjectsByBucketNameResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContinuationToken) > 0 {
		i -= len(m.ContinuationToken)
		copy(dAtA[i:], m.ContinuationToken)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.ContinuationToken)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CommonPrefixes) > 0 {
		for iNdEx := len(m.CommonPrefixes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CommonPrefixes[iNdEx])
			copy(dAtA[i:], m.CommonPrefixes[iNdEx])
			i = encodeVarintMetadata(dAtA, i, uint64(len(m.CommonPrefixes[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Delimiter) > 0 {
		i -= len(m.Delimiter)
		copy(dAtA[i:], m.Delimiter)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Delimiter)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.NextContinuationToken) > 0 {
		i -= len(m.NextContinuationToken)
		copy(dAtA[i:], m.NextContinuationToken)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.NextContinuationToken)))
		i--
		dAtA[i] = 0x2a
	}
	if m.IsTruncated {
		i--
		if m.IsTruncated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.MaxKeys != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.MaxKeys))
		i--
		dAtA[i] = 0x18
	}
	if m.KeyCount != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.KeyCount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Objects) > 0 {
		for iNdEx := len(m.Objects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Objects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetBucketByBucketNameRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetBucketByBucketNameRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetBucketByBucketNameRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsFullList {
		i--
		if m.IsFullList {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.BucketName) > 0 {
		i -= len(m.BucketName)
		copy(dAtA[i:], m.BucketName)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.BucketName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetBucketByBucketNameResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetBucketByBucketNameResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetBucketByBucketNameResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Bucket != nil {
		{
			size, err := m.Bucket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetBucketByBucketIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetBucketByBucketIDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetBucketByBucketIDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsFullList {
		i--
		if m.IsFullList {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.BucketId != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.BucketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetBucketByBucketIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetBucketByBucketIDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetBucketByBucketIDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Bucket != nil {
		{
			size, err := m.Bucket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpListDeletedObjectsByBlockNumberRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpListDeletedObjectsByBlockNumberRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpListDeletedObjectsByBlockNumberRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsFullList {
		i--
		if m.IsFullList {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.EndBlockNumber != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.EndBlockNumber))
		i--
		dAtA[i] = 0x10
	}
	if m.StartBlockNumber != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.StartBlockNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GfSpListDeletedObjectsByBlockNumberRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpListDeletedObjectsByBlockNumberRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpListDeletedObjectsByBlockNumberRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndBlockNumber != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.EndBlockNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Objects) > 0 {
		for iNdEx := len(m.Objects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Objects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetUserBucketsCountRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetUserBucketsCountRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetUserBucketsCountRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AccountId) > 0 {
		i -= len(m.AccountId)
		copy(dAtA[i:], m.AccountId)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.AccountId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetUserBucketsCountResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetUserBucketsCountResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetUserBucketsCountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GfSpListExpiredBucketsBySpRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpListExpiredBucketsBySpRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpListExpiredBucketsBySpRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PrimarySpAddress) > 0 {
		i -= len(m.PrimarySpAddress)
		copy(dAtA[i:], m.PrimarySpAddress)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.PrimarySpAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.CreateAt != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GfSpListExpiredBucketsBySpResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpListExpiredBucketsBySpResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpListExpiredBucketsBySpResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Buckets) > 0 {
		for iNdEx := len(m.Buckets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Buckets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetObjectMetaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetObjectMetaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetObjectMetaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsFullList {
		i--
		if m.IsFullList {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.BucketName) > 0 {
		i -= len(m.BucketName)
		copy(dAtA[i:], m.BucketName)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.BucketName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ObjectName) > 0 {
		i -= len(m.ObjectName)
		copy(dAtA[i:], m.ObjectName)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.ObjectName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetObjectMetaResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetObjectMetaResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetObjectMetaResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Object != nil {
		{
			size, err := m.Object.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetPaymentByBucketNameRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetPaymentByBucketNameRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetPaymentByBucketNameRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsFullList {
		i--
		if m.IsFullList {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.BucketName) > 0 {
		i -= len(m.BucketName)
		copy(dAtA[i:], m.BucketName)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.BucketName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetPaymentByBucketNameResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetPaymentByBucketNameResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetPaymentByBucketNameResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StreamRecord != nil {
		{
			size, err := m.StreamRecord.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetPaymentByBucketIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetPaymentByBucketIDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetPaymentByBucketIDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsFullList {
		i--
		if m.IsFullList {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.BucketId != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.BucketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetPaymentByBucketIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetPaymentByBucketIDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetPaymentByBucketIDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StreamRecord != nil {
		{
			size, err := m.StreamRecord.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetBucketMetaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetBucketMetaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetBucketMetaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsFullList {
		i--
		if m.IsFullList {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.BucketName) > 0 {
		i -= len(m.BucketName)
		copy(dAtA[i:], m.BucketName)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.BucketName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetBucketMetaResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetBucketMetaResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetBucketMetaResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StreamRecord != nil {
		{
			size, err := m.StreamRecord.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Bucket != nil {
		{
			size, err := m.Bucket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetEndpointBySpAddressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetEndpointBySpAddressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetEndpointBySpAddressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SpAddress) > 0 {
		i -= len(m.SpAddress)
		copy(dAtA[i:], m.SpAddress)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.SpAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetEndpointBySpAddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetEndpointBySpAddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetEndpointBySpAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetBucketReadQuotaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetBucketReadQuotaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetBucketReadQuotaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.YearMonth) > 0 {
		i -= len(m.YearMonth)
		copy(dAtA[i:], m.YearMonth)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.YearMonth)))
		i--
		dAtA[i] = 0x12
	}
	if m.BucketInfo != nil {
		{
			size, err := m.BucketInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpGetBucketReadQuotaResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpGetBucketReadQuotaResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpGetBucketReadQuotaResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConsumedSize != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.ConsumedSize))
		i--
		dAtA[i] = 0x20
	}
	if m.SpFreeQuotaSize != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.SpFreeQuotaSize))
		i--
		dAtA[i] = 0x18
	}
	if m.ChargedQuotaSize != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.ChargedQuotaSize))
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpListBucketReadRecordRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpListBucketReadRecordRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpListBucketReadRecordRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxRecordNum != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.MaxRecordNum))
		i--
		dAtA[i] = 0x20
	}
	if m.EndTimestampUs != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.EndTimestampUs))
		i--
		dAtA[i] = 0x18
	}
	if m.StartTimestampUs != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.StartTimestampUs))
		i--
		dAtA[i] = 0x10
	}
	if m.BucketInfo != nil {
		{
			size, err := m.BucketInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReadSize != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.ReadSize))
		i--
		dAtA[i] = 0x28
	}
	if m.TimestampUs != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.TimestampUs))
		i--
		dAtA[i] = 0x20
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ObjectId != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.ObjectId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ObjectName) > 0 {
		i -= len(m.ObjectName)
		copy(dAtA[i:], m.ObjectName)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.ObjectName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpListBucketReadRecordResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpListBucketReadRecordResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpListBucketReadRecordResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextStartTimestampUs != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.NextStartTimestampUs))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReadRecords) > 0 {
		for iNdEx := len(m.ReadRecords) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReadRecords[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GfSpQueryUploadProgressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpQueryUploadProgressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpQueryUploadProgressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ObjectId != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.ObjectId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GfSpQueryUploadProgressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GfSpQueryUploadProgressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GfSpQueryUploadProgressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMetadata(dAtA []byte, offset int, v uint64) int {
	offset -= sovMetadata(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Bucket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BucketInfo != nil {
		l = m.BucketInfo.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.Removed {
		n += 2
	}
	if m.DeleteAt != 0 {
		n += 1 + sovMetadata(uint64(m.DeleteAt))
	}
	l = len(m.DeleteReason)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.CreateTxHash)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.UpdateTxHash)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.UpdateAt != 0 {
		n += 1 + sovMetadata(uint64(m.UpdateAt))
	}
	if m.UpdateTime != 0 {
		n += 1 + sovMetadata(uint64(m.UpdateTime))
	}
	return n
}

func (m *Object) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectInfo != nil {
		l = m.ObjectInfo.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.LockedBalance)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.Removed {
		n += 2
	}
	if m.UpdateAt != 0 {
		n += 1 + sovMetadata(uint64(m.UpdateAt))
	}
	if m.DeleteAt != 0 {
		n += 1 + sovMetadata(uint64(m.DeleteAt))
	}
	l = len(m.DeleteReason)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.CreateTxHash)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.UpdateTxHash)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.SealTxHash)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *GfSpGetUserBucketsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *GfSpGetUserBucketsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Buckets) > 0 {
		for _, e := range m.Buckets {
			l = e.Size()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	return n
}

func (m *GfSpListObjectsByBucketNameRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BucketName)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.MaxKeys != 0 {
		n += 1 + sovMetadata(uint64(m.MaxKeys))
	}
	l = len(m.StartAfter)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.ContinuationToken)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.Delimiter)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *GfSpListObjectsByBucketNameResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	if m.KeyCount != 0 {
		n += 1 + sovMetadata(uint64(m.KeyCount))
	}
	if m.MaxKeys != 0 {
		n += 1 + sovMetadata(uint64(m.MaxKeys))
	}
	if m.IsTruncated {
		n += 2
	}
	l = len(m.NextContinuationToken)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.Delimiter)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if len(m.CommonPrefixes) > 0 {
		for _, s := range m.CommonPrefixes {
			l = len(s)
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	l = len(m.ContinuationToken)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *GfSpGetBucketByBucketNameRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BucketName)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.IsFullList {
		n += 2
	}
	return n
}

func (m *GfSpGetBucketByBucketNameResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bucket != nil {
		l = m.Bucket.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *GfSpGetBucketByBucketIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BucketId != 0 {
		n += 1 + sovMetadata(uint64(m.BucketId))
	}
	if m.IsFullList {
		n += 2
	}
	return n
}

func (m *GfSpGetBucketByBucketIDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bucket != nil {
		l = m.Bucket.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *GfSpListDeletedObjectsByBlockNumberRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartBlockNumber != 0 {
		n += 1 + sovMetadata(uint64(m.StartBlockNumber))
	}
	if m.EndBlockNumber != 0 {
		n += 1 + sovMetadata(uint64(m.EndBlockNumber))
	}
	if m.IsFullList {
		n += 2
	}
	return n
}

func (m *GfSpListDeletedObjectsByBlockNumberRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	if m.EndBlockNumber != 0 {
		n += 1 + sovMetadata(uint64(m.EndBlockNumber))
	}
	return n
}

func (m *GfSpGetUserBucketsCountRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *GfSpGetUserBucketsCountResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovMetadata(uint64(m.Count))
	}
	return n
}

func (m *GfSpListExpiredBucketsBySpRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateAt != 0 {
		n += 1 + sovMetadata(uint64(m.CreateAt))
	}
	l = len(m.PrimarySpAddress)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovMetadata(uint64(m.Limit))
	}
	return n
}

func (m *GfSpListExpiredBucketsBySpResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Buckets) > 0 {
		for _, e := range m.Buckets {
			l = e.Size()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	return n
}

func (m *GfSpGetObjectMetaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ObjectName)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.BucketName)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.IsFullList {
		n += 2
	}
	return n
}

func (m *GfSpGetObjectMetaResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *GfSpGetPaymentByBucketNameRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BucketName)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.IsFullList {
		n += 2
	}
	return n
}

func (m *GfSpGetPaymentByBucketNameResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StreamRecord != nil {
		l = m.StreamRecord.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *GfSpGetPaymentByBucketIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BucketId != 0 {
		n += 1 + sovMetadata(uint64(m.BucketId))
	}
	if m.IsFullList {
		n += 2
	}
	return n
}

func (m *GfSpGetPaymentByBucketIDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StreamRecord != nil {
		l = m.StreamRecord.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *GfSpGetBucketMetaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BucketName)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.IsFullList {
		n += 2
	}
	return n
}

func (m *GfSpGetBucketMetaResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bucket != nil {
		l = m.Bucket.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.StreamRecord != nil {
		l = m.StreamRecord.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *GfSpGetEndpointBySpAddressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpAddress)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *GfSpGetEndpointBySpAddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *GfSpGetBucketReadQuotaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BucketInfo != nil {
		l = m.BucketInfo.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.YearMonth)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *GfSpGetBucketReadQuotaResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.ChargedQuotaSize != 0 {
		n += 1 + sovMetadata(uint64(m.ChargedQuotaSize))
	}
	if m.SpFreeQuotaSize != 0 {
		n += 1 + sovMetadata(uint64(m.SpFreeQuotaSize))
	}
	if m.ConsumedSize != 0 {
		n += 1 + sovMetadata(uint64(m.ConsumedSize))
	}
	return n
}

func (m *GfSpListBucketReadRecordRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BucketInfo != nil {
		l = m.BucketInfo.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.StartTimestampUs != 0 {
		n += 1 + sovMetadata(uint64(m.StartTimestampUs))
	}
	if m.EndTimestampUs != 0 {
		n += 1 + sovMetadata(uint64(m.EndTimestampUs))
	}
	if m.MaxRecordNum != 0 {
		n += 1 + sovMetadata(uint64(m.MaxRecordNum))
	}
	return n
}

func (m *ReadRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ObjectName)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.ObjectId != 0 {
		n += 1 + sovMetadata(uint64(m.ObjectId))
	}
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.TimestampUs != 0 {
		n += 1 + sovMetadata(uint64(m.TimestampUs))
	}
	if m.ReadSize != 0 {
		n += 1 + sovMetadata(uint64(m.ReadSize))
	}
	return n
}

func (m *GfSpListBucketReadRecordResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	if len(m.ReadRecords) > 0 {
		for _, e := range m.ReadRecords {
			l = e.Size()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	if m.NextStartTimestampUs != 0 {
		n += 1 + sovMetadata(uint64(m.NextStartTimestampUs))
	}
	return n
}

func (m *GfSpQueryUploadProgressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectId != 0 {
		n += 1 + sovMetadata(uint64(m.ObjectId))
	}
	return n
}

func (m *GfSpQueryUploadProgressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMetadata(uint64(m.State))
	}
	return n
}

func sovMetadata(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMetadata(x uint64) (n int) {
	return sovMetadata(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Bucket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bucket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bucket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BucketInfo == nil {
				m.BucketInfo = &types.BucketInfo{}
			}
			if err := m.BucketInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Removed = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteAt", wireType)
			}
			m.DeleteAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeleteReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			m.UpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Object) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Object: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Object: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectInfo == nil {
				m.ObjectInfo = &types.ObjectInfo{}
			}
			if err := m.ObjectInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockedBalance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockedBalance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Removed = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteAt", wireType)
			}
			m.DeleteAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeleteReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SealTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SealTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetUserBucketsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetUserBucketsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetUserBucketsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetUserBucketsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetUserBucketsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetUserBucketsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buckets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buckets = append(m.Buckets, &Bucket{})
			if err := m.Buckets[len(m.Buckets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpListObjectsByBucketNameRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpListObjectsByBucketNameRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpListObjectsByBucketNameRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BucketName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxKeys", wireType)
			}
			m.MaxKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxKeys |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartAfter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartAfter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContinuationToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContinuationToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delimiter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delimiter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpListObjectsByBucketNameResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpListObjectsByBucketNameResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpListObjectsByBucketNameResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &Object{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyCount", wireType)
			}
			m.KeyCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxKeys", wireType)
			}
			m.MaxKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxKeys |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTruncated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTruncated = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextContinuationToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextContinuationToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delimiter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delimiter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonPrefixes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommonPrefixes = append(m.CommonPrefixes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContinuationToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContinuationToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetBucketByBucketNameRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetBucketByBucketNameRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetBucketByBucketNameRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BucketName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFullList", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFullList = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetBucketByBucketNameResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetBucketByBucketNameResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetBucketByBucketNameResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bucket == nil {
				m.Bucket = &Bucket{}
			}
			if err := m.Bucket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetBucketByBucketIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetBucketByBucketIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetBucketByBucketIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketId", wireType)
			}
			m.BucketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFullList", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFullList = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetBucketByBucketIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetBucketByBucketIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetBucketByBucketIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bucket == nil {
				m.Bucket = &Bucket{}
			}
			if err := m.Bucket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpListDeletedObjectsByBlockNumberRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpListDeletedObjectsByBlockNumberRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpListDeletedObjectsByBlockNumberRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBlockNumber", wireType)
			}
			m.StartBlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBlockNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndBlockNumber", wireType)
			}
			m.EndBlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndBlockNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFullList", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFullList = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpListDeletedObjectsByBlockNumberRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpListDeletedObjectsByBlockNumberRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpListDeletedObjectsByBlockNumberRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &Object{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndBlockNumber", wireType)
			}
			m.EndBlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndBlockNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetUserBucketsCountRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetUserBucketsCountRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetUserBucketsCountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetUserBucketsCountResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetUserBucketsCountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetUserBucketsCountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpListExpiredBucketsBySpRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpListExpiredBucketsBySpRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpListExpiredBucketsBySpRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimarySpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimarySpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpListExpiredBucketsBySpResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpListExpiredBucketsBySpResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpListExpiredBucketsBySpResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buckets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buckets = append(m.Buckets, &Bucket{})
			if err := m.Buckets[len(m.Buckets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetObjectMetaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetObjectMetaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetObjectMetaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BucketName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFullList", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFullList = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetObjectMetaResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetObjectMetaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetObjectMetaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Object{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetPaymentByBucketNameRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetPaymentByBucketNameRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetPaymentByBucketNameRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BucketName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFullList", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFullList = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetPaymentByBucketNameResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetPaymentByBucketNameResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetPaymentByBucketNameResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StreamRecord == nil {
				m.StreamRecord = &types1.StreamRecord{}
			}
			if err := m.StreamRecord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetPaymentByBucketIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetPaymentByBucketIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetPaymentByBucketIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketId", wireType)
			}
			m.BucketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFullList", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFullList = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetPaymentByBucketIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetPaymentByBucketIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetPaymentByBucketIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StreamRecord == nil {
				m.StreamRecord = &types1.StreamRecord{}
			}
			if err := m.StreamRecord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetBucketMetaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetBucketMetaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetBucketMetaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BucketName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFullList", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFullList = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetBucketMetaResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetBucketMetaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetBucketMetaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bucket == nil {
				m.Bucket = &Bucket{}
			}
			if err := m.Bucket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StreamRecord == nil {
				m.StreamRecord = &types1.StreamRecord{}
			}
			if err := m.StreamRecord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetEndpointBySpAddressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetEndpointBySpAddressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetEndpointBySpAddressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetEndpointBySpAddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetEndpointBySpAddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetEndpointBySpAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetBucketReadQuotaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetBucketReadQuotaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetBucketReadQuotaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BucketInfo == nil {
				m.BucketInfo = &types.BucketInfo{}
			}
			if err := m.BucketInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YearMonth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.YearMonth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpGetBucketReadQuotaResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpGetBucketReadQuotaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpGetBucketReadQuotaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &gfsperrors.GfSpError{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChargedQuotaSize", wireType)
			}
			m.ChargedQuotaSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChargedQuotaSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpFreeQuotaSize", wireType)
			}
			m.SpFreeQuotaSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpFreeQuotaSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumedSize", wireType)
			}
			m.ConsumedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsumedSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpListBucketReadRecordRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpListBucketReadRecordRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpListBucketReadRecordRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BucketInfo == nil {
				m.BucketInfo = &types.BucketInfo{}
			}
			if err := m.BucketInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestampUs", wireType)
			}
			m.StartTimestampUs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimestampUs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTimestampUs", wireType)
			}
			m.EndTimestampUs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTimestampUs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRecordNum", wireType)
			}
			m.MaxRecordNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRecordNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			m.ObjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampUs", wireType)
			}
			m.TimestampUs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampUs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadSize", wireType)
			}
			m.ReadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpListBucketReadRecordResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpListBucketReadRecordResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpListBucketReadRecordResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &gfsperrors.GfSpError{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadRecords", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadRecords = append(m.ReadRecords, &ReadRecord{})
			if err := m.ReadRecords[len(m.ReadRecords)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStartTimestampUs", wireType)
			}
			m.NextStartTimestampUs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextStartTimestampUs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpQueryUploadProgressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpQueryUploadProgressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpQueryUploadProgressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			m.ObjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GfSpQueryUploadProgressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GfSpQueryUploadProgressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GfSpQueryUploadProgressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &gfsperrors.GfSpError{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= types2.JobState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetadata(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMetadata
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMetadata
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMetadata
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMetadata        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetadata          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMetadata = fmt.Errorf("proto: unexpected end of group")
)
